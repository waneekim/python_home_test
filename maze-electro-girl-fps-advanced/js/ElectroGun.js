/**
 * ElectroGun: ê³ ê¸‰ ì „ê¸° ì´ ì‹œìŠ¤í…œ
 * 
 * í•µì‹¬ ê¸°ëŠ¥:
 * - ë‹¤ë‹¨ê³„ ì—…ê·¸ë ˆì´ë“œ ì‹œìŠ¤í…œ
 * - ì „ê¸° ì´í™íŠ¸ ë° íŒŒí‹°í´ ì‹œìŠ¤í…œ
 * - ì°¨ì§€ ìƒ· ë° íŠ¹ìˆ˜ ëŠ¥ë ¥
 * - ì‚¬ìš´ë“œ ë° ì‹œê°ì  í”¼ë“œë°±
 * - ì¿¨ë‹¤ìš´ ë° ì˜¤ë²„íˆíŠ¸ ì‹œìŠ¤í…œ
 */
class ElectroGun {
    constructor(scene, camera, gameManager) {
        this.scene = scene;
        this.camera = camera;
        this.gameManager = gameManager;
        
        // ì´ ë ˆë²¨ ë° ì—…ê·¸ë ˆì´ë“œ
        this.level = 1;
        this.maxLevel = 5;
        this.upgradePoints = 0;
        
        // ê¸°ë³¸ ë°œì‚¬ ì„¤ì •
        this.baseDamage = 25;
        this.baseFireRate = 0.5; // ì´ˆë‹¹ ë°œì‚¬ íšŸìˆ˜
        this.baseRange = 50;
        this.baseSpeed = 30;
        
        // í˜„ì¬ ëŠ¥ë ¥ì¹˜ (ì—…ê·¸ë ˆì´ë“œì— ë”°ë¼ ë³€í•¨)
        this.damage = this.baseDamage;
        this.fireRate = this.baseFireRate;
        this.range = this.baseRange;
        this.speed = this.baseSpeed;
        
        // ë°œì‚¬ ìƒíƒœ
        this.canShoot = true;
        this.lastShotTime = 0;
        this.ammunition = Infinity; // ë¬´í•œ íƒ„ì•½ (ì „ê¸° ì—ë„ˆì§€)
        
        // ì°¨ì§€ ìƒ· ì‹œìŠ¤í…œ
        this.chargeShot = {
            enabled: false,
            charging: false,
            chargeTime: 0,
            maxChargeTime: 2.0,
            damageMultiplier: 3.0,
            consumed: false
        };
        
        // ì˜¤ë²„íˆíŠ¸ ì‹œìŠ¤í…œ
        this.overheat = {
            enabled: false,
            heat: 0,
            maxHeat: 100,
            cooldownRate: 20, // ì´ˆë‹¹ ì—´ ê°ì†ŒëŸ‰
            heatPerShot: 15,
            overheated: false,
            cooldownTime: 2.0,
            currentCooldown: 0
        };
        
        // íŠ¹ìˆ˜ ëŠ¥ë ¥
        this.abilities = {
            piercing: false,        // ê´€í†µ ëŠ¥ë ¥
            chainLightning: false, // ì—°ì‡„ ë²ˆê°œ
            explosive: false,      // í­ë°œ íƒ„í™˜
            homing: false,         // ìœ ë„ íƒ„í™˜
            rapid: false           // ì—°ì‚¬ ëª¨ë“œ
        };
        
        // ì´ì•Œ ê´€ë¦¬
        this.bullets = [];
        this.maxBullets = 50;
        
        // ì´í™íŠ¸ ì‹œìŠ¤í…œ
        this.effects = {
            muzzleFlash: null,
            sparks: [],
            lightningBolts: []
        };
        
        // ì´ ëª¨ë¸
        this.gunModel = null;
        this.gunLight = null;
        
        // ì‚¬ìš´ë“œ (ì›¹ ì˜¤ë””ì˜¤ ë¯¸êµ¬í˜„ ì‹œ ì½˜ì†” ë¡œê·¸)
        this.sounds = {
            shoot: 'electro_shot',
            charge: 'charge_buildup',
            overheat: 'overheat_warning'
        };
        
        this.init();
    }
    
    init() {
        this.createGunModel();
        this.setupUpgrades();
        this.createEffects();
    }\n    \n    /**\n     * ì „ê¸° ì´ ëª¨ë¸ ìƒì„±\n     */\n    createGunModel() {\n        // ì´ ê·¸ë£¹\n        this.gunModel = new THREE.Group();\n        \n        // ì´ì‹ \n        const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.03, 0.3, 8);\n        const barrelMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x444444,\n            shininess: 100\n        });\n        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);\n        barrel.rotation.x = Math.PI / 2;\n        barrel.position.set(0.1, -0.1, -0.2);\n        this.gunModel.add(barrel);\n        \n        // ì „ê¸° ì½”ì¼ ì¥ì‹\n        const coilGeometry = new THREE.TorusGeometry(0.04, 0.008, 4, 12);\n        const coilMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x00FFFF,\n            emissive: 0x001111\n        });\n        \n        for (let i = 0; i < 3; i++) {\n            const coil = new THREE.Mesh(coilGeometry, coilMaterial);\n            coil.position.set(0.1, -0.1, -0.1 - (i * 0.08));\n            coil.rotation.x = Math.PI / 2;\n            this.gunModel.add(coil);\n        }\n        \n        // ì†ì¡ì´\n        const gripGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.04);\n        const gripMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });\n        const grip = new THREE.Mesh(gripGeometry, gripMaterial);\n        grip.position.set(0.1, -0.2, -0.05);\n        this.gunModel.add(grip);\n        \n        // ì „ê¸° ì—ë„ˆì§€ í‘œì‹œ í¬ë¦¬ìŠ¤íƒˆ\n        const crystalGeometry = new THREE.OctahedronGeometry(0.02, 0);\n        const crystalMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x8A2BE2,\n            emissive: 0x221144,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.energyCrystal = new THREE.Mesh(crystalGeometry, crystalMaterial);\n        this.energyCrystal.position.set(0.1, -0.05, -0.1);\n        this.gunModel.add(this.energyCrystal);\n        \n        // ì´êµ¬ ë¼ì´íŠ¸\n        this.gunLight = new THREE.PointLight(0x00FFFF, 0, 2);\n        this.gunLight.position.set(0.1, -0.1, -0.35);\n        this.gunModel.add(this.gunLight);\n        \n        // ì¹´ë©”ë¼ì— ì´ ë¶€ì°©\n        this.gunModel.position.set(0.3, -0.2, -0.5);\n        this.camera.add(this.gunModel);\n    }\n    \n    /**\n     * ì—…ê·¸ë ˆì´ë“œ ì‹œìŠ¤í…œ ì„¤ì •\n     */\n    setupUpgrades() {\n        this.upgrades = {\n            1: {\n                damage: this.baseDamage,\n                fireRate: this.baseFireRate,\n                abilities: []\n            },\n            2: {\n                damage: this.baseDamage * 1.3,\n                fireRate: this.baseFireRate * 1.2,\n                abilities: ['piercing']\n            },\n            3: {\n                damage: this.baseDamage * 1.6,\n                fireRate: this.baseFireRate * 1.5,\n                abilities: ['piercing', 'chainLightning']\n            },\n            4: {\n                damage: this.baseDamage * 2.0,\n                fireRate: this.baseFireRate * 1.8,\n                abilities: ['piercing', 'chainLightning', 'explosive']\n            },\n            5: {\n                damage: this.baseDamage * 2.5,\n                fireRate: this.baseFireRate * 2.2,\n                abilities: ['piercing', 'chainLightning', 'explosive', 'homing', 'rapid']\n            }\n        };\n        \n        this.applyUpgrade();\n    }\n    \n    /**\n     * ì´í™íŠ¸ ì‹œìŠ¤í…œ ìƒì„±\n     */\n    createEffects() {\n        // ì´êµ¬ ì„¬ê´‘\n        const flashGeometry = new THREE.SphereGeometry(0.1, 8, 6);\n        const flashMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x00FFFF,\n            transparent: true,\n            opacity: 0\n        });\n        this.effects.muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);\n        this.effects.muzzleFlash.position.set(0.1, -0.1, -0.35);\n        this.gunModel.add(this.effects.muzzleFlash);\n    }\n    \n    /**\n     * ë©”ì¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜\n     */\n    update(deltaTime) {\n        this.updateCooldowns(deltaTime);\n        this.updateBullets(deltaTime);\n        this.updateEffects(deltaTime);\n        this.updateGunAnimation(deltaTime);\n        this.updateOverheat(deltaTime);\n        this.updateChargeShot(deltaTime);\n    }\n    \n    /**\n     * ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸\n     */\n    updateCooldowns(deltaTime) {\n        const currentTime = performance.now() / 1000;\n        \n        if (!this.canShoot && currentTime - this.lastShotTime >= 1 / this.fireRate) {\n            this.canShoot = true;\n        }\n        \n        if (this.overheat.overheated) {\n            this.overheat.currentCooldown -= deltaTime;\n            if (this.overheat.currentCooldown <= 0) {\n                this.overheat.overheated = false;\n                this.overheat.heat = 0;\n            }\n        }\n    }\n    \n    /**\n     * ì´ì•Œ ì—…ë°ì´íŠ¸\n     */\n    updateBullets(deltaTime) {\n        for (let i = this.bullets.length - 1; i >= 0; i--) {\n            const bullet = this.bullets[i];\n            \n            // ì´ì•Œ ì´ë™\n            bullet.position.add(\n                bullet.userData.velocity.clone().multiplyScalar(deltaTime)\n            );\n            \n            // ìˆ˜ëª… ê°ì†Œ\n            bullet.userData.life -= deltaTime;\n            \n            // ìœ ë„ ê¸°ëŠ¥ (homing)\n            if (this.abilities.homing && bullet.userData.target) {\n                this.updateHomingBullet(bullet, deltaTime);\n            }\n            \n            // ìˆ˜ëª… ì¢…ë£Œ ë˜ëŠ” ë²”ìœ„ ì´ˆê³¼\n            if (bullet.userData.life <= 0) {\n                this.destroyBullet(i);\n                continue;\n            }\n            \n            // ì¶©ëŒ ê²€ì‚¬\n            this.checkBulletCollisions(bullet, i);\n        }\n    }\n    \n    /**\n     * ìœ ë„ ì´ì•Œ ì—…ë°ì´íŠ¸\n     */\n    updateHomingBullet(bullet, deltaTime) {\n        if (!bullet.userData.target || !bullet.userData.target.userData.health) {\n            return;\n        }\n        \n        const targetPos = bullet.userData.target.position;\n        const bulletPos = bullet.position;\n        const direction = targetPos.clone().sub(bulletPos).normalize();\n        \n        // í˜„ì¬ ì†ë„ì™€ íƒ€ê²Ÿ ë°©í–¥ ë³´ê°„\n        const homingStrength = 5.0;\n        bullet.userData.velocity.lerp(\n            direction.multiplyScalar(this.speed),\n            homingStrength * deltaTime\n        );\n    }\n    \n    /**\n     * ì´ì•Œ ì¶©ëŒ ê²€ì‚¬\n     */\n    checkBulletCollisions(bullet, bulletIndex) {\n        // ì ê³¼ì˜ ì¶©ëŒ\n        if (this.gameManager.enemyManager) {\n            const hit = this.gameManager.enemyManager.checkBulletCollision(bullet);\n            if (hit) {\n                this.handleEnemyHit(hit.enemy, bullet, bulletIndex);\n                return;\n            }\n        }\n        \n        // ë²½ê³¼ì˜ ì¶©ëŒ\n        if (this.gameManager.maze) {\n            const wallHit = this.gameManager.maze.checkBulletCollision(bullet.position);\n            if (wallHit) {\n                this.handleWallHit(bullet, bulletIndex, wallHit.point, wallHit.normal);\n            }\n        }\n    }\n    \n    /**\n     * ì  í”¼ê²© ì²˜ë¦¬\n     */\n    handleEnemyHit(enemy, bullet, bulletIndex) {\n        let damage = bullet.userData.damage;\n        \n        // ì°¨ì§€ ìƒ· ë°ë¯¸ì§€ ë³´ë„ˆìŠ¤\n        if (bullet.userData.charged) {\n            damage *= this.chargeShot.damageMultiplier;\n        }\n        \n        // ì ì—ê²Œ ë°ë¯¸ì§€ ì ìš©\n        const killed = enemy.takeDamage(damage);\n        \n        // ì—°ì‡„ ë²ˆê°œ (chainLightning)\n        if (this.abilities.chainLightning) {\n            this.createChainLightning(bullet.position, enemy);\n        }\n        \n        // í­ë°œ íš¨ê³¼ (explosive)\n        if (this.abilities.explosive) {\n            this.createExplosion(bullet.position);\n        }\n        \n        // ê´€í†µ ëŠ¥ë ¥ì´ ì—†ìœ¼ë©´ ì´ì•Œ ì œê±°\n        if (!this.abilities.piercing) {\n            this.destroyBullet(bulletIndex);\n        }\n        \n        // íƒ€ê²© ì´í™íŠ¸\n        this.createHitEffect(bullet.position);\n        \n        // ì ìˆ˜ ì—…ë°ì´íŠ¸\n        if (killed && this.gameManager.uiManager) {\n            this.gameManager.uiManager.addEnemyKill();\n        }\n    }\n    \n    /**\n     * ë²½ ì¶©ëŒ ì²˜ë¦¬\n     */\n    handleWallHit(bullet, bulletIndex, hitPoint, normal) {\n        // ë²½ íƒ€ê²© ì´í™íŠ¸\n        this.createWallHitEffect(hitPoint, normal);\n        \n        // ì´ì•Œ ì œê±° (ê´€í†µ ëŠ¥ë ¥ì´ ìˆì–´ë„ ë²½ì€ ëš«ì§€ ëª»í•¨)\n        this.destroyBullet(bulletIndex);\n    }\n    \n    /**\n     * ë°œì‚¬ í•¨ìˆ˜\n     */\n    shoot() {\n        if (!this.canShoot || this.overheat.overheated) {\n            return false;\n        }\n        \n        // ì˜¤ë²„íˆíŠ¸ ì²´í¬\n        if (this.overheat.enabled && this.overheat.heat >= this.overheat.maxHeat) {\n            this.overheat.overheated = true;\n            this.overheat.currentCooldown = this.overheat.cooldownTime;\n            this.playSound(this.sounds.overheat);\n            return false;\n        }\n        \n        // ì´ì•Œ ìƒì„±\n        this.createBullet();\n        \n        // ë°œì‚¬ í›„ ì²˜ë¦¬\n        this.canShoot = false;\n        this.lastShotTime = performance.now() / 1000;\n        \n        // ì˜¤ë²„íˆíŠ¸ ì¦ê°€\n        if (this.overheat.enabled) {\n            this.overheat.heat += this.overheat.heatPerShot;\n        }\n        \n        // ì´í™íŠ¸ ë° ì‚¬ìš´ë“œ\n        this.createMuzzleFlash();\n        this.playSound(this.sounds.shoot);\n        \n        // ì¹´ë©”ë¼ ì…°ì´í¬\n        if (this.gameManager.playerController) {\n            this.gameManager.playerController.addCameraShake(0.1);\n        }\n        \n        return true;\n    }\n    \n    /**\n     * ì°¨ì§€ ìƒ· ì‹œì‘\n     */\n    startChargeShot() {\n        if (!this.chargeShot.enabled) return;\n        \n        this.chargeShot.charging = true;\n        this.chargeShot.chargeTime = 0;\n        this.playSound(this.sounds.charge);\n    }\n    \n    /**\n     * ì°¨ì§€ ìƒ· í•´ì œ\n     */\n    releaseChargeShot() {\n        if (!this.chargeShot.charging) return;\n        \n        if (this.chargeShot.chargeTime >= this.chargeShot.maxChargeTime) {\n            // ì™„ì „ ì°¨ì§€ëœ ì´ì•Œ ë°œì‚¬\n            this.createChargedBullet();\n        } else {\n            // ì¼ë°˜ ë°œì‚¬\n            this.shoot();\n        }\n        \n        this.chargeShot.charging = false;\n        this.chargeShot.chargeTime = 0;\n    }\n    \n    /**\n     * ì¼ë°˜ ì´ì•Œ ìƒì„±\n     */\n    createBullet() {\n        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 6);\n        const bulletMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x00FFFF,\n            transparent: true,\n            opacity: 0.8\n        });\n        \n        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);\n        \n        // ì´êµ¬ ìœ„ì¹˜ì—ì„œ ì‹œì‘\n        const muzzlePosition = new THREE.Vector3(0.1, -0.1, -0.35);\n        muzzlePosition.applyMatrix4(this.camera.matrixWorld);\n        bullet.position.copy(muzzlePosition);\n        \n        // ë°œì‚¬ ë°©í–¥\n        const direction = new THREE.Vector3();\n        this.camera.getWorldDirection(direction);\n        \n        // ì´ì•Œ ë°ì´í„°\n        bullet.userData = {\n            velocity: direction.multiplyScalar(this.speed),\n            damage: this.damage,\n            life: this.range / this.speed,\n            charged: false,\n            target: this.abilities.homing ? this.findNearestEnemy(bullet.position) : null\n        };\n        \n        this.bullets.push(bullet);\n        this.scene.add(bullet);\n        \n        // ì „ê¸° íŠ¸ë ˆì¼ ì´í™íŠ¸\n        this.createElectricTrail(bullet);\n    }\n    \n    /**\n     * ì°¨ì§€ëœ ì´ì•Œ ìƒì„±\n     */\n    createChargedBullet() {\n        const bulletGeometry = new THREE.SphereGeometry(0.1, 12, 8);\n        const bulletMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x8A2BE2,\n            transparent: true,\n            opacity: 0.9\n        });\n        \n        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);\n        \n        const muzzlePosition = new THREE.Vector3(0.1, -0.1, -0.35);\n        muzzlePosition.applyMatrix4(this.camera.matrixWorld);\n        bullet.position.copy(muzzlePosition);\n        \n        const direction = new THREE.Vector3();\n        this.camera.getWorldDirection(direction);\n        \n        bullet.userData = {\n            velocity: direction.multiplyScalar(this.speed * 1.5),\n            damage: this.damage,\n            life: (this.range * 1.5) / (this.speed * 1.5),\n            charged: true,\n            target: this.abilities.homing ? this.findNearestEnemy(bullet.position) : null\n        };\n        \n        this.bullets.push(bullet);\n        this.scene.add(bullet);\n        \n        // ê°•í™”ëœ ì „ê¸° ì´í™íŠ¸\n        this.createChargedElectricTrail(bullet);\n    }\n    \n    /**\n     * ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìœ ë„íƒ„ìš©)\n     */\n    findNearestEnemy(position) {\n        if (!this.gameManager.enemyManager) return null;\n        \n        const enemies = this.gameManager.enemyManager.getAliveEnemies();\n        let nearest = null;\n        let minDistance = Infinity;\n        \n        enemies.forEach(enemy => {\n            const distance = position.distanceTo(enemy.position);\n            if (distance < minDistance && distance < 20) { // 20m ë²”ìœ„ ë‚´\n                minDistance = distance;\n                nearest = enemy;\n            }\n        });\n        \n        return nearest;\n    }\n    \n    /**\n     * ì´ì•Œ ì œê±°\n     */\n    destroyBullet(index) {\n        const bullet = this.bullets[index];\n        if (bullet) {\n            this.scene.remove(bullet);\n            this.bullets.splice(index, 1);\n        }\n    }\n    \n    /**\n     * ì—…ê·¸ë ˆì´ë“œ ì ìš©\n     */\n    applyUpgrade() {\n        if (!this.upgrades[this.level]) return;\n        \n        const upgrade = this.upgrades[this.level];\n        this.damage = upgrade.damage;\n        this.fireRate = upgrade.fireRate;\n        \n        // ëŠ¥ë ¥ í™œì„±í™”\n        Object.keys(this.abilities).forEach(ability => {\n            this.abilities[ability] = upgrade.abilities.includes(ability);\n        });\n        \n        // ì°¨ì§€ ìƒ· í™œì„±í™” (ë ˆë²¨ 3ë¶€í„°)\n        this.chargeShot.enabled = this.level >= 3;\n        \n        // ì˜¤ë²„íˆíŠ¸ ì‹œìŠ¤í…œ í™œì„±í™” (ë ˆë²¨ 2ë¶€í„°)\n        this.overheat.enabled = this.level >= 2;\n        \n        // ì´ ëª¨ë¸ ì—…ê·¸ë ˆì´ë“œ ì‹œê°í™”\n        this.updateGunVisuals();\n        \n        console.log(`ì „ê¸° ì´ ë ˆë²¨ ${this.level} ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!`);\n    }\n    \n    /**\n     * ì „ê¸° íë¸Œë¡œ ì—…ê·¸ë ˆì´ë“œ\n     */\n    upgrade(cubeValue = 20) {\n        this.upgradePoints += cubeValue;\n        \n        const pointsNeeded = this.level * 50; // ë ˆë²¨ë‹¹ í•„ìš” í¬ì¸íŠ¸ ì¦ê°€\n        \n        if (this.upgradePoints >= pointsNeeded && this.level < this.maxLevel) {\n            this.upgradePoints -= pointsNeeded;\n            this.level++;\n            this.applyUpgrade();\n            \n            // UI ì—…ë°ì´íŠ¸\n            if (this.gameManager.uiManager) {\n                this.gameManager.uiManager.updateWeaponLevel(this.level, this.maxLevel);\n            }\n            \n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * ì´ ì™¸í˜• ì—…ë°ì´íŠ¸\n     */\n    updateGunVisuals() {\n        if (!this.energyCrystal) return;\n        \n        // ë ˆë²¨ì— ë”°ë¥¸ í¬ë¦¬ìŠ¤íƒˆ ìƒ‰ìƒ ë³€í™”\n        const colors = [\n            0x8A2BE2, // ë³´ë¼\n            0x00FFFF, // ì‹œì•ˆ\n            0xFFD700, // ê¸ˆìƒ‰\n            0xFF6B6B, // ë¹¨ê°•\n            0x00FF00  // ì´ˆë¡\n        ];\n        \n        this.energyCrystal.material.color.setHex(colors[this.level - 1] || colors[0]);\n        this.energyCrystal.material.emissive.setHex((colors[this.level - 1] || colors[0]) * 0.3);\n        \n        // í¬ê¸° ì¦ê°€\n        const scale = 1 + (this.level - 1) * 0.2;\n        this.energyCrystal.scale.setScalar(scale);\n    }\n    \n    /**\n     * ì´í™íŠ¸ ì—…ë°ì´íŠ¸\n     */\n    updateEffects(deltaTime) {\n        // ì´êµ¬ ì„¬ê´‘ í˜ì´ë“œ\n        if (this.effects.muzzleFlash && this.effects.muzzleFlash.material.opacity > 0) {\n            this.effects.muzzleFlash.material.opacity -= deltaTime * 10;\n        }\n        \n        // ì—ë„ˆì§€ í¬ë¦¬ìŠ¤íƒˆ íšŒì „\n        if (this.energyCrystal) {\n            this.energyCrystal.rotation.x += deltaTime * 2;\n            this.energyCrystal.rotation.y += deltaTime * 1.5;\n        }\n    }\n    \n    /**\n     * ì´ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸\n     */\n    updateGunAnimation(deltaTime) {\n        if (!this.gunModel) return;\n        \n        // ë°˜ë™ ì• ë‹ˆë©”ì´ì…˜ (ë°œì‚¬ ì§í›„)\n        const timeSinceShot = (performance.now() / 1000) - this.lastShotTime;\n        if (timeSinceShot < 0.1) {\n            const recoil = Math.max(0, 0.1 - timeSinceShot) * 5;\n            this.gunModel.position.z = -0.5 + recoil * 0.05;\n            this.gunModel.rotation.x = recoil * 0.1;\n        } else {\n            // ì›ë˜ ìœ„ì¹˜ë¡œ ë³µê·€\n            this.gunModel.position.z = -0.5;\n            this.gunModel.rotation.x = 0;\n        }\n    }\n    \n    /**\n     * ì˜¤ë²„íˆíŠ¸ ì—…ë°ì´íŠ¸\n     */\n    updateOverheat(deltaTime) {\n        if (!this.overheat.enabled) return;\n        \n        // ì—´ ìì—° ê°ì†Œ\n        if (!this.overheat.overheated && this.overheat.heat > 0) {\n            this.overheat.heat = Math.max(0, this.overheat.heat - this.overheat.cooldownRate * deltaTime);\n        }\n        \n        // UI ì—…ë°ì´íŠ¸\n        if (this.gameManager.uiManager) {\n            this.gameManager.uiManager.updateOverheat(\n                this.overheat.heat, \n                this.overheat.maxHeat, \n                this.overheat.overheated\n            );\n        }\n    }\n    \n    /**\n     * ì°¨ì§€ ìƒ· ì—…ë°ì´íŠ¸\n     */\n    updateChargeShot(deltaTime) {\n        if (this.chargeShot.charging) {\n            this.chargeShot.chargeTime += deltaTime;\n            \n            // ì°¨ì§• ì´í™íŠ¸\n            this.updateChargingEffects();\n        }\n    }\n    \n    /**\n     * ì°¨ì§• ì´í™íŠ¸ ì—…ë°ì´íŠ¸\n     */\n    updateChargingEffects() {\n        if (!this.gunLight) return;\n        \n        const chargeRatio = Math.min(1, this.chargeShot.chargeTime / this.chargeShot.maxChargeTime);\n        \n        // ì´êµ¬ ë¼ì´íŠ¸ ê°•ë„ ì¦ê°€\n        this.gunLight.intensity = chargeRatio * 2;\n        \n        // ì™„ì „ ì°¨ì§€ ì‹œ ìƒ‰ìƒ ë³€í™”\n        if (chargeRatio >= 1) {\n            this.gunLight.color.setHex(0xFF00FF); // ë§ˆì  íƒ€\n        } else {\n            this.gunLight.color.setHex(0x00FFFF); // ì‹œì•ˆ\n        }\n    }\n    \n    /**\n     * ì´êµ¬ ì„¬ê´‘ ìƒì„±\n     */\n    createMuzzleFlash() {\n        if (this.effects.muzzleFlash) {\n            this.effects.muzzleFlash.material.opacity = 1;\n        }\n        \n        if (this.gunLight) {\n            this.gunLight.intensity = 1;\n            setTimeout(() => {\n                if (this.gunLight) this.gunLight.intensity = 0;\n            }, 50);\n        }\n    }\n    \n    /**\n     * ì „ê¸° íŠ¸ë ˆì¼ ì´í™íŠ¸ ìƒì„±\n     */\n    createElectricTrail(bullet) {\n        // ê°„ë‹¨í•œ íŒŒí‹°í´ ì‹œìŠ¤í…œìœ¼ë¡œ ì „ê¸° íš¨ê³¼ êµ¬í˜„\n        // ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ë” ë³µì¡í•œ íŒŒí‹°í´ ì‹œìŠ¤í…œ ì‚¬ìš©\n    }\n    \n    /**\n     * ì°¨ì§€ëœ ì „ê¸° íŠ¸ë ˆì¼ ìƒì„±\n     */\n    createChargedElectricTrail(bullet) {\n        // ë” ê°•ë ¥í•œ ì „ê¸° íš¨ê³¼\n    }\n    \n    /**\n     * íƒ€ê²© ì´í™íŠ¸ ìƒì„±\n     */\n    createHitEffect(position) {\n        // íƒ€ê²© ì§€ì ì— ì „ê¸° ìŠ¤íŒŒí¬ ì´í™íŠ¸\n    }\n    \n    /**\n     * ë²½ íƒ€ê²© ì´í™íŠ¸\n     */\n    createWallHitEffect(position, normal) {\n        // ë²½ì— ì „ê¸° ìêµ­ ì´í™íŠ¸\n    }\n    \n    /**\n     * ì—°ì‡„ ë²ˆê°œ ìƒì„±\n     */\n    createChainLightning(origin, firstTarget) {\n        // ì£¼ë³€ ì ë“¤ì—ê²Œ ì—°ì‡„ë˜ëŠ” ë²ˆê°œ íš¨ê³¼\n    }\n    \n    /**\n     * í­ë°œ ìƒì„±\n     */\n    createExplosion(position) {\n        // ì „ê¸° í­ë°œ ì´í™íŠ¸ ë° ë²”ìœ„ ë°ë¯¸ì§€\n    }\n    \n    /**\n     * ì‚¬ìš´ë“œ ì¬ìƒ (ì›¹ ì˜¤ë””ì˜¤ ë¯¸êµ¬í˜„ ì‹œ ì½˜ì†”)\n     */\n    playSound(soundName) {\n        console.log(`ğŸ”Š ${soundName} ì‚¬ìš´ë“œ ì¬ìƒ`);\n    }\n    \n    /**\n     * ì´ ìƒíƒœ ë¦¬ì…‹\n     */\n    reset() {\n        this.level = 1;\n        this.upgradePoints = 0;\n        this.overheat.heat = 0;\n        this.overheat.overheated = false;\n        this.chargeShot.charging = false;\n        this.chargeShot.chargeTime = 0;\n        \n        // ëª¨ë“  ì´ì•Œ ì œê±°\n        this.bullets.forEach(bullet => {\n            this.scene.remove(bullet);\n        });\n        this.bullets = [];\n        \n        this.applyUpgrade();\n    }\n    \n    /**\n     * í˜„ì¬ ìƒíƒœ ë°˜í™˜\n     */\n    getState() {\n        return {\n            level: this.level,\n            upgradePoints: this.upgradePoints,\n            damage: this.damage,\n            fireRate: this.fireRate,\n            abilities: { ...this.abilities },\n            overheat: { ...this.overheat },\n            bulletCount: this.bullets.length\n        };\n    }\n}