/**
 * ElectroGun: 고급 전기 총 시스템
 * 
 * 핵심 기능:
 * - 다단계 업그레이드 시스템
 * - 전기 이펙트 및 파티클 시스템
 * - 차지 샷 및 특수 능력
 * - 사운드 및 시각적 피드백
 * - 쿨다운 및 오버히트 시스템
 */
class ElectroGun {
    constructor(scene, camera, gameManager) {
        this.scene = scene;
        this.camera = camera;
        this.gameManager = gameManager;
        
        // 총 레벨 및 업그레이드
        this.level = 1;
        this.maxLevel = 5;
        this.upgradePoints = 0;
        
        // 기본 발사 설정
        this.baseDamage = 25;
        this.baseFireRate = 0.5; // 초당 발사 횟수
        this.baseRange = 50;
        this.baseSpeed = 30;
        
        // 현재 능력치 (업그레이드에 따라 변함)
        this.damage = this.baseDamage;
        this.fireRate = this.baseFireRate;
        this.range = this.baseRange;
        this.speed = this.baseSpeed;
        
        // 발사 상태
        this.canShoot = true;
        this.lastShotTime = 0;
        this.ammunition = Infinity; // 무한 탄약 (전기 에너지)
        
        // 차지 샷 시스템
        this.chargeShot = {
            enabled: false,
            charging: false,
            chargeTime: 0,
            maxChargeTime: 2.0,
            damageMultiplier: 3.0,
            consumed: false
        };
        
        // 오버히트 시스템
        this.overheat = {
            enabled: false,
            heat: 0,
            maxHeat: 100,
            cooldownRate: 20, // 초당 열 감소량
            heatPerShot: 15,
            overheated: false,
            cooldownTime: 2.0,
            currentCooldown: 0
        };
        
        // 특수 능력
        this.abilities = {
            piercing: false,        // 관통 능력
            chainLightning: false, // 연쇄 번개
            explosive: false,      // 폭발 탄환
            homing: false,         // 유도 탄환
            rapid: false           // 연사 모드
        };
        
        // 총알 관리
        this.bullets = [];
        this.maxBullets = 50;
        
        // 이펙트 시스템
        this.effects = {
            muzzleFlash: null,
            sparks: [],
            lightningBolts: []
        };
        
        // 총 모델
        this.gunModel = null;
        this.gunLight = null;
        
        // 사운드 (웹 오디오 미구현 시 콘솔 로그)
        this.sounds = {
            shoot: 'electro_shot',
            charge: 'charge_buildup',
            overheat: 'overheat_warning'
        };
        
        this.init();
    }
    
    init() {
        this.createGunModel();
        this.setupUpgrades();
        this.createEffects();
    }\n    \n    /**\n     * 전기 총 모델 생성\n     */\n    createGunModel() {\n        // 총 그룹\n        this.gunModel = new THREE.Group();\n        \n        // 총신\n        const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.03, 0.3, 8);\n        const barrelMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x444444,\n            shininess: 100\n        });\n        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);\n        barrel.rotation.x = Math.PI / 2;\n        barrel.position.set(0.1, -0.1, -0.2);\n        this.gunModel.add(barrel);\n        \n        // 전기 코일 장식\n        const coilGeometry = new THREE.TorusGeometry(0.04, 0.008, 4, 12);\n        const coilMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x00FFFF,\n            emissive: 0x001111\n        });\n        \n        for (let i = 0; i < 3; i++) {\n            const coil = new THREE.Mesh(coilGeometry, coilMaterial);\n            coil.position.set(0.1, -0.1, -0.1 - (i * 0.08));\n            coil.rotation.x = Math.PI / 2;\n            this.gunModel.add(coil);\n        }\n        \n        // 손잡이\n        const gripGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.04);\n        const gripMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });\n        const grip = new THREE.Mesh(gripGeometry, gripMaterial);\n        grip.position.set(0.1, -0.2, -0.05);\n        this.gunModel.add(grip);\n        \n        // 전기 에너지 표시 크리스탈\n        const crystalGeometry = new THREE.OctahedronGeometry(0.02, 0);\n        const crystalMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x8A2BE2,\n            emissive: 0x221144,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.energyCrystal = new THREE.Mesh(crystalGeometry, crystalMaterial);\n        this.energyCrystal.position.set(0.1, -0.05, -0.1);\n        this.gunModel.add(this.energyCrystal);\n        \n        // 총구 라이트\n        this.gunLight = new THREE.PointLight(0x00FFFF, 0, 2);\n        this.gunLight.position.set(0.1, -0.1, -0.35);\n        this.gunModel.add(this.gunLight);\n        \n        // 카메라에 총 부착\n        this.gunModel.position.set(0.3, -0.2, -0.5);\n        this.camera.add(this.gunModel);\n    }\n    \n    /**\n     * 업그레이드 시스템 설정\n     */\n    setupUpgrades() {\n        this.upgrades = {\n            1: {\n                damage: this.baseDamage,\n                fireRate: this.baseFireRate,\n                abilities: []\n            },\n            2: {\n                damage: this.baseDamage * 1.3,\n                fireRate: this.baseFireRate * 1.2,\n                abilities: ['piercing']\n            },\n            3: {\n                damage: this.baseDamage * 1.6,\n                fireRate: this.baseFireRate * 1.5,\n                abilities: ['piercing', 'chainLightning']\n            },\n            4: {\n                damage: this.baseDamage * 2.0,\n                fireRate: this.baseFireRate * 1.8,\n                abilities: ['piercing', 'chainLightning', 'explosive']\n            },\n            5: {\n                damage: this.baseDamage * 2.5,\n                fireRate: this.baseFireRate * 2.2,\n                abilities: ['piercing', 'chainLightning', 'explosive', 'homing', 'rapid']\n            }\n        };\n        \n        this.applyUpgrade();\n    }\n    \n    /**\n     * 이펙트 시스템 생성\n     */\n    createEffects() {\n        // 총구 섬광\n        const flashGeometry = new THREE.SphereGeometry(0.1, 8, 6);\n        const flashMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x00FFFF,\n            transparent: true,\n            opacity: 0\n        });\n        this.effects.muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);\n        this.effects.muzzleFlash.position.set(0.1, -0.1, -0.35);\n        this.gunModel.add(this.effects.muzzleFlash);\n    }\n    \n    /**\n     * 메인 업데이트 함수\n     */\n    update(deltaTime) {\n        this.updateCooldowns(deltaTime);\n        this.updateBullets(deltaTime);\n        this.updateEffects(deltaTime);\n        this.updateGunAnimation(deltaTime);\n        this.updateOverheat(deltaTime);\n        this.updateChargeShot(deltaTime);\n    }\n    \n    /**\n     * 쿨다운 업데이트\n     */\n    updateCooldowns(deltaTime) {\n        const currentTime = performance.now() / 1000;\n        \n        if (!this.canShoot && currentTime - this.lastShotTime >= 1 / this.fireRate) {\n            this.canShoot = true;\n        }\n        \n        if (this.overheat.overheated) {\n            this.overheat.currentCooldown -= deltaTime;\n            if (this.overheat.currentCooldown <= 0) {\n                this.overheat.overheated = false;\n                this.overheat.heat = 0;\n            }\n        }\n    }\n    \n    /**\n     * 총알 업데이트\n     */\n    updateBullets(deltaTime) {\n        for (let i = this.bullets.length - 1; i >= 0; i--) {\n            const bullet = this.bullets[i];\n            \n            // 총알 이동\n            bullet.position.add(\n                bullet.userData.velocity.clone().multiplyScalar(deltaTime)\n            );\n            \n            // 수명 감소\n            bullet.userData.life -= deltaTime;\n            \n            // 유도 기능 (homing)\n            if (this.abilities.homing && bullet.userData.target) {\n                this.updateHomingBullet(bullet, deltaTime);\n            }\n            \n            // 수명 종료 또는 범위 초과\n            if (bullet.userData.life <= 0) {\n                this.destroyBullet(i);\n                continue;\n            }\n            \n            // 충돌 검사\n            this.checkBulletCollisions(bullet, i);\n        }\n    }\n    \n    /**\n     * 유도 총알 업데이트\n     */\n    updateHomingBullet(bullet, deltaTime) {\n        if (!bullet.userData.target || !bullet.userData.target.userData.health) {\n            return;\n        }\n        \n        const targetPos = bullet.userData.target.position;\n        const bulletPos = bullet.position;\n        const direction = targetPos.clone().sub(bulletPos).normalize();\n        \n        // 현재 속도와 타겟 방향 보간\n        const homingStrength = 5.0;\n        bullet.userData.velocity.lerp(\n            direction.multiplyScalar(this.speed),\n            homingStrength * deltaTime\n        );\n    }\n    \n    /**\n     * 총알 충돌 검사\n     */\n    checkBulletCollisions(bullet, bulletIndex) {\n        // 적과의 충돌\n        if (this.gameManager.enemyManager) {\n            const hit = this.gameManager.enemyManager.checkBulletCollision(bullet);\n            if (hit) {\n                this.handleEnemyHit(hit.enemy, bullet, bulletIndex);\n                return;\n            }\n        }\n        \n        // 벽과의 충돌\n        if (this.gameManager.maze) {\n            const wallHit = this.gameManager.maze.checkBulletCollision(bullet.position);\n            if (wallHit) {\n                this.handleWallHit(bullet, bulletIndex, wallHit.point, wallHit.normal);\n            }\n        }\n    }\n    \n    /**\n     * 적 피격 처리\n     */\n    handleEnemyHit(enemy, bullet, bulletIndex) {\n        let damage = bullet.userData.damage;\n        \n        // 차지 샷 데미지 보너스\n        if (bullet.userData.charged) {\n            damage *= this.chargeShot.damageMultiplier;\n        }\n        \n        // 적에게 데미지 적용\n        const killed = enemy.takeDamage(damage);\n        \n        // 연쇄 번개 (chainLightning)\n        if (this.abilities.chainLightning) {\n            this.createChainLightning(bullet.position, enemy);\n        }\n        \n        // 폭발 효과 (explosive)\n        if (this.abilities.explosive) {\n            this.createExplosion(bullet.position);\n        }\n        \n        // 관통 능력이 없으면 총알 제거\n        if (!this.abilities.piercing) {\n            this.destroyBullet(bulletIndex);\n        }\n        \n        // 타격 이펙트\n        this.createHitEffect(bullet.position);\n        \n        // 점수 업데이트\n        if (killed && this.gameManager.uiManager) {\n            this.gameManager.uiManager.addEnemyKill();\n        }\n    }\n    \n    /**\n     * 벽 충돌 처리\n     */\n    handleWallHit(bullet, bulletIndex, hitPoint, normal) {\n        // 벽 타격 이펙트\n        this.createWallHitEffect(hitPoint, normal);\n        \n        // 총알 제거 (관통 능력이 있어도 벽은 뚫지 못함)\n        this.destroyBullet(bulletIndex);\n    }\n    \n    /**\n     * 발사 함수\n     */\n    shoot() {\n        if (!this.canShoot || this.overheat.overheated) {\n            return false;\n        }\n        \n        // 오버히트 체크\n        if (this.overheat.enabled && this.overheat.heat >= this.overheat.maxHeat) {\n            this.overheat.overheated = true;\n            this.overheat.currentCooldown = this.overheat.cooldownTime;\n            this.playSound(this.sounds.overheat);\n            return false;\n        }\n        \n        // 총알 생성\n        this.createBullet();\n        \n        // 발사 후 처리\n        this.canShoot = false;\n        this.lastShotTime = performance.now() / 1000;\n        \n        // 오버히트 증가\n        if (this.overheat.enabled) {\n            this.overheat.heat += this.overheat.heatPerShot;\n        }\n        \n        // 이펙트 및 사운드\n        this.createMuzzleFlash();\n        this.playSound(this.sounds.shoot);\n        \n        // 카메라 셰이크\n        if (this.gameManager.playerController) {\n            this.gameManager.playerController.addCameraShake(0.1);\n        }\n        \n        return true;\n    }\n    \n    /**\n     * 차지 샷 시작\n     */\n    startChargeShot() {\n        if (!this.chargeShot.enabled) return;\n        \n        this.chargeShot.charging = true;\n        this.chargeShot.chargeTime = 0;\n        this.playSound(this.sounds.charge);\n    }\n    \n    /**\n     * 차지 샷 해제\n     */\n    releaseChargeShot() {\n        if (!this.chargeShot.charging) return;\n        \n        if (this.chargeShot.chargeTime >= this.chargeShot.maxChargeTime) {\n            // 완전 차지된 총알 발사\n            this.createChargedBullet();\n        } else {\n            // 일반 발사\n            this.shoot();\n        }\n        \n        this.chargeShot.charging = false;\n        this.chargeShot.chargeTime = 0;\n    }\n    \n    /**\n     * 일반 총알 생성\n     */\n    createBullet() {\n        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 6);\n        const bulletMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x00FFFF,\n            transparent: true,\n            opacity: 0.8\n        });\n        \n        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);\n        \n        // 총구 위치에서 시작\n        const muzzlePosition = new THREE.Vector3(0.1, -0.1, -0.35);\n        muzzlePosition.applyMatrix4(this.camera.matrixWorld);\n        bullet.position.copy(muzzlePosition);\n        \n        // 발사 방향\n        const direction = new THREE.Vector3();\n        this.camera.getWorldDirection(direction);\n        \n        // 총알 데이터\n        bullet.userData = {\n            velocity: direction.multiplyScalar(this.speed),\n            damage: this.damage,\n            life: this.range / this.speed,\n            charged: false,\n            target: this.abilities.homing ? this.findNearestEnemy(bullet.position) : null\n        };\n        \n        this.bullets.push(bullet);\n        this.scene.add(bullet);\n        \n        // 전기 트레일 이펙트\n        this.createElectricTrail(bullet);\n    }\n    \n    /**\n     * 차지된 총알 생성\n     */\n    createChargedBullet() {\n        const bulletGeometry = new THREE.SphereGeometry(0.1, 12, 8);\n        const bulletMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x8A2BE2,\n            transparent: true,\n            opacity: 0.9\n        });\n        \n        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);\n        \n        const muzzlePosition = new THREE.Vector3(0.1, -0.1, -0.35);\n        muzzlePosition.applyMatrix4(this.camera.matrixWorld);\n        bullet.position.copy(muzzlePosition);\n        \n        const direction = new THREE.Vector3();\n        this.camera.getWorldDirection(direction);\n        \n        bullet.userData = {\n            velocity: direction.multiplyScalar(this.speed * 1.5),\n            damage: this.damage,\n            life: (this.range * 1.5) / (this.speed * 1.5),\n            charged: true,\n            target: this.abilities.homing ? this.findNearestEnemy(bullet.position) : null\n        };\n        \n        this.bullets.push(bullet);\n        this.scene.add(bullet);\n        \n        // 강화된 전기 이펙트\n        this.createChargedElectricTrail(bullet);\n    }\n    \n    /**\n     * 가장 가까운 적 찾기 (유도탄용)\n     */\n    findNearestEnemy(position) {\n        if (!this.gameManager.enemyManager) return null;\n        \n        const enemies = this.gameManager.enemyManager.getAliveEnemies();\n        let nearest = null;\n        let minDistance = Infinity;\n        \n        enemies.forEach(enemy => {\n            const distance = position.distanceTo(enemy.position);\n            if (distance < minDistance && distance < 20) { // 20m 범위 내\n                minDistance = distance;\n                nearest = enemy;\n            }\n        });\n        \n        return nearest;\n    }\n    \n    /**\n     * 총알 제거\n     */\n    destroyBullet(index) {\n        const bullet = this.bullets[index];\n        if (bullet) {\n            this.scene.remove(bullet);\n            this.bullets.splice(index, 1);\n        }\n    }\n    \n    /**\n     * 업그레이드 적용\n     */\n    applyUpgrade() {\n        if (!this.upgrades[this.level]) return;\n        \n        const upgrade = this.upgrades[this.level];\n        this.damage = upgrade.damage;\n        this.fireRate = upgrade.fireRate;\n        \n        // 능력 활성화\n        Object.keys(this.abilities).forEach(ability => {\n            this.abilities[ability] = upgrade.abilities.includes(ability);\n        });\n        \n        // 차지 샷 활성화 (레벨 3부터)\n        this.chargeShot.enabled = this.level >= 3;\n        \n        // 오버히트 시스템 활성화 (레벨 2부터)\n        this.overheat.enabled = this.level >= 2;\n        \n        // 총 모델 업그레이드 시각화\n        this.updateGunVisuals();\n        \n        console.log(`전기 총 레벨 ${this.level} 업그레이드 완료!`);\n    }\n    \n    /**\n     * 전기 큐브로 업그레이드\n     */\n    upgrade(cubeValue = 20) {\n        this.upgradePoints += cubeValue;\n        \n        const pointsNeeded = this.level * 50; // 레벨당 필요 포인트 증가\n        \n        if (this.upgradePoints >= pointsNeeded && this.level < this.maxLevel) {\n            this.upgradePoints -= pointsNeeded;\n            this.level++;\n            this.applyUpgrade();\n            \n            // UI 업데이트\n            if (this.gameManager.uiManager) {\n                this.gameManager.uiManager.updateWeaponLevel(this.level, this.maxLevel);\n            }\n            \n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * 총 외형 업데이트\n     */\n    updateGunVisuals() {\n        if (!this.energyCrystal) return;\n        \n        // 레벨에 따른 크리스탈 색상 변화\n        const colors = [\n            0x8A2BE2, // 보라\n            0x00FFFF, // 시안\n            0xFFD700, // 금색\n            0xFF6B6B, // 빨강\n            0x00FF00  // 초록\n        ];\n        \n        this.energyCrystal.material.color.setHex(colors[this.level - 1] || colors[0]);\n        this.energyCrystal.material.emissive.setHex((colors[this.level - 1] || colors[0]) * 0.3);\n        \n        // 크기 증가\n        const scale = 1 + (this.level - 1) * 0.2;\n        this.energyCrystal.scale.setScalar(scale);\n    }\n    \n    /**\n     * 이펙트 업데이트\n     */\n    updateEffects(deltaTime) {\n        // 총구 섬광 페이드\n        if (this.effects.muzzleFlash && this.effects.muzzleFlash.material.opacity > 0) {\n            this.effects.muzzleFlash.material.opacity -= deltaTime * 10;\n        }\n        \n        // 에너지 크리스탈 회전\n        if (this.energyCrystal) {\n            this.energyCrystal.rotation.x += deltaTime * 2;\n            this.energyCrystal.rotation.y += deltaTime * 1.5;\n        }\n    }\n    \n    /**\n     * 총 애니메이션 업데이트\n     */\n    updateGunAnimation(deltaTime) {\n        if (!this.gunModel) return;\n        \n        // 반동 애니메이션 (발사 직후)\n        const timeSinceShot = (performance.now() / 1000) - this.lastShotTime;\n        if (timeSinceShot < 0.1) {\n            const recoil = Math.max(0, 0.1 - timeSinceShot) * 5;\n            this.gunModel.position.z = -0.5 + recoil * 0.05;\n            this.gunModel.rotation.x = recoil * 0.1;\n        } else {\n            // 원래 위치로 복귀\n            this.gunModel.position.z = -0.5;\n            this.gunModel.rotation.x = 0;\n        }\n    }\n    \n    /**\n     * 오버히트 업데이트\n     */\n    updateOverheat(deltaTime) {\n        if (!this.overheat.enabled) return;\n        \n        // 열 자연 감소\n        if (!this.overheat.overheated && this.overheat.heat > 0) {\n            this.overheat.heat = Math.max(0, this.overheat.heat - this.overheat.cooldownRate * deltaTime);\n        }\n        \n        // UI 업데이트\n        if (this.gameManager.uiManager) {\n            this.gameManager.uiManager.updateOverheat(\n                this.overheat.heat, \n                this.overheat.maxHeat, \n                this.overheat.overheated\n            );\n        }\n    }\n    \n    /**\n     * 차지 샷 업데이트\n     */\n    updateChargeShot(deltaTime) {\n        if (this.chargeShot.charging) {\n            this.chargeShot.chargeTime += deltaTime;\n            \n            // 차징 이펙트\n            this.updateChargingEffects();\n        }\n    }\n    \n    /**\n     * 차징 이펙트 업데이트\n     */\n    updateChargingEffects() {\n        if (!this.gunLight) return;\n        \n        const chargeRatio = Math.min(1, this.chargeShot.chargeTime / this.chargeShot.maxChargeTime);\n        \n        // 총구 라이트 강도 증가\n        this.gunLight.intensity = chargeRatio * 2;\n        \n        // 완전 차지 시 색상 변화\n        if (chargeRatio >= 1) {\n            this.gunLight.color.setHex(0xFF00FF); // 마젠타\n        } else {\n            this.gunLight.color.setHex(0x00FFFF); // 시안\n        }\n    }\n    \n    /**\n     * 총구 섬광 생성\n     */\n    createMuzzleFlash() {\n        if (this.effects.muzzleFlash) {\n            this.effects.muzzleFlash.material.opacity = 1;\n        }\n        \n        if (this.gunLight) {\n            this.gunLight.intensity = 1;\n            setTimeout(() => {\n                if (this.gunLight) this.gunLight.intensity = 0;\n            }, 50);\n        }\n    }\n    \n    /**\n     * 전기 트레일 이펙트 생성\n     */\n    createElectricTrail(bullet) {\n        // 간단한 파티클 시스템으로 전기 효과 구현\n        // 실제 게임에서는 더 복잡한 파티클 시스템 사용\n    }\n    \n    /**\n     * 차지된 전기 트레일 생성\n     */\n    createChargedElectricTrail(bullet) {\n        // 더 강력한 전기 효과\n    }\n    \n    /**\n     * 타격 이펙트 생성\n     */\n    createHitEffect(position) {\n        // 타격 지점에 전기 스파크 이펙트\n    }\n    \n    /**\n     * 벽 타격 이펙트\n     */\n    createWallHitEffect(position, normal) {\n        // 벽에 전기 자국 이펙트\n    }\n    \n    /**\n     * 연쇄 번개 생성\n     */\n    createChainLightning(origin, firstTarget) {\n        // 주변 적들에게 연쇄되는 번개 효과\n    }\n    \n    /**\n     * 폭발 생성\n     */\n    createExplosion(position) {\n        // 전기 폭발 이펙트 및 범위 데미지\n    }\n    \n    /**\n     * 사운드 재생 (웹 오디오 미구현 시 콘솔)\n     */\n    playSound(soundName) {\n        console.log(`🔊 ${soundName} 사운드 재생`);\n    }\n    \n    /**\n     * 총 상태 리셋\n     */\n    reset() {\n        this.level = 1;\n        this.upgradePoints = 0;\n        this.overheat.heat = 0;\n        this.overheat.overheated = false;\n        this.chargeShot.charging = false;\n        this.chargeShot.chargeTime = 0;\n        \n        // 모든 총알 제거\n        this.bullets.forEach(bullet => {\n            this.scene.remove(bullet);\n        });\n        this.bullets = [];\n        \n        this.applyUpgrade();\n    }\n    \n    /**\n     * 현재 상태 반환\n     */\n    getState() {\n        return {\n            level: this.level,\n            upgradePoints: this.upgradePoints,\n            damage: this.damage,\n            fireRate: this.fireRate,\n            abilities: { ...this.abilities },\n            overheat: { ...this.overheat },\n            bulletCount: this.bullets.length\n        };\n    }\n}