/**
 * GameManager: í•µì‹¬ ê²Œì„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ
 * 
 * í•µì‹¬ ê¸°ëŠ¥:
 * - ì „ì²´ ê²Œì„ ë£¨í”„ ë° ìƒíƒœ ê´€ë¦¬
 * - ì‹œìŠ¤í…œ ê°„ ìƒí˜¸ì‘ìš© ì¡°ìœ¨
 * - 3D ë¯¸ë¡œ í™˜ê²½ ìƒì„±
 * - ê²Œì„ ì§„í–‰ ë° ìŠ¹ë¦¬/íŒ¨ë°° ì¡°ê±´
 * - ì €ì¥/ë¡œë“œ ì‹œìŠ¤í…œ
 */
class GameManager {
    constructor() {
        // ê²Œì„ ìƒíƒœ
        this.gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver', 'victory'
        this.isInitialized = false;
        
        // Three.js í•µì‹¬ ìš”ì†Œë“¤
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        
        // ê²Œì„ ì‹œìŠ¤í…œë“¤
        this.playerController = null;
        this.electroGun = null;
        this.enemyManager = null;
        this.itemManager = null;
        this.uiManager = null;
        this.effectsManager = null;
        
        // ë¯¸ë¡œ ì‹œìŠ¤í…œ
        this.maze = {\n            layout: null,\n            walls: [],\n            floors: [],\n            size: { width: 15, height: 15 }\n        };\n        \n        // ê²Œì„ ì„¤ì •\n        this.settings = {\n            difficulty: 'normal', // 'easy', 'normal', 'hard'\n            renderDistance: 100,\n            shadowQuality: 'medium',\n            particleCount: 'high'\n        };\n        \n        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§\n        this.performance = {\n            fps: 60,\n            frameTime: 0,\n            lastFrameTime: 0\n        };\n        \n        // ê²Œì„ íƒ€ì´ë¨¸\n        this.gameTimer = {\n            startTime: 0,\n            currentTime: 0,\n            deltaTime: 0\n        };\n        \n        // ìŠ¹ë¦¬ ì¡°ê±´\n        this.winConditions = {\n            coinsRequired: 10, // ìµœì†Œ ìˆ˜ì§‘í•´ì•¼ í•  ì½”ì¸ ìˆ˜\n            enemiesRequired: 5, // ìµœì†Œ ì²˜ì¹˜í•´ì•¼ í•  ì  ìˆ˜\n            timeLimit: 300 // 5ë¶„ ì‹œê°„ ì œí•œ (ì„ íƒì‚¬í•­)\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * ê²Œì„ ì´ˆê¸°í™”\n     */\n    init() {\n        this.initThreeJS();\n        this.createMaze();\n        this.initSystems();\n        this.setupLighting();\n        this.startGameLoop();\n        \n        this.isInitialized = true;\n        console.log('ğŸ® ê²Œì„ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì™„ë£Œ');\n    }\n    \n    /**\n     * Three.js ì´ˆê¸°í™”\n     */\n    initThreeJS() {\n        // Scene ìƒì„±\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(0x001122);\n        this.scene.fog = new THREE.Fog(0x001122, 10, this.settings.renderDistance);\n        \n        // Camera ìƒì„±\n        this.camera = new THREE.PerspectiveCamera(\n            75, \n            window.innerWidth / window.innerHeight, \n            0.1, \n            this.settings.renderDistance\n        );\n        \n        // Renderer ìƒì„±\n        this.renderer = new THREE.WebGLRenderer({ \n            antialias: true,\n            powerPreference: 'high-performance'\n        });\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\n        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n        \n        // DOMì— ì¶”ê°€\n        const container = document.getElementById('gameContainer');\n        if (container) {\n            container.appendChild(this.renderer.domElement);\n        }\n        \n        // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸\n        window.addEventListener('resize', () => this.onWindowResize());\n    }\n    \n    /**\n     * 3D ë¯¸ë¡œ ìƒì„±\n     */\n    createMaze() {\n        // ë¯¸ë¡œ ë ˆì´ì•„ì›ƒ (1=ë²½, 0=ê¸¸, 2=ì½”ì¸ ìœ„ì¹˜, 3=ì „ê¸°íë¸Œ ìœ„ì¹˜, 4=ì  ìŠ¤í°)\n        this.maze.layout = [\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n            [1,0,2,0,1,0,0,0,1,0,0,2,0,0,1],\n            [1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],\n            [1,0,0,0,0,0,1,0,0,0,1,0,3,0,1],\n            [1,1,1,1,0,1,1,1,1,0,1,0,1,0,1],\n            [1,0,0,2,0,0,0,0,0,0,1,0,0,0,1],\n            [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],\n            [1,0,0,0,0,0,1,0,0,0,0,0,1,4,1],\n            [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],\n            [1,2,1,0,0,0,0,0,1,0,3,0,0,0,1],\n            [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],\n            [1,0,0,0,1,0,0,0,0,0,1,0,4,0,1],\n            [1,1,1,0,1,0,1,1,1,0,1,0,1,1,1],\n            [1,0,2,0,0,0,1,0,0,0,0,0,0,2,1],\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n        ];\n        \n        this.generateMazeGeometry();\n    }\n    \n    /**\n     * ë¯¸ë¡œ ì§€ì˜¤ë©”íŠ¸ë¦¬ ìƒì„±\n     */\n    generateMazeGeometry() {\n        // ì¬ë£Œ ìƒì„±\n        const wallMaterial = new THREE.MeshLambertMaterial({ \n            color: 0x4a4a4a,\n            map: this.createWallTexture()\n        });\n        \n        const floorMaterial = new THREE.MeshLambertMaterial({ \n            color: 0x333333,\n            map: this.createFloorTexture()\n        });\n        \n        const ceilingMaterial = new THREE.MeshLambertMaterial({ \n            color: 0x222222\n        });\n        \n        // ë°”ë‹¥ ìƒì„±\n        const floorGeometry = new THREE.PlaneGeometry(this.maze.size.width, this.maze.size.height);\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n        floor.rotation.x = -Math.PI / 2;\n        floor.position.y = 0;\n        floor.receiveShadow = true;\n        floor.userData.isFloor = true;\n        this.scene.add(floor);\n        \n        // ì²œì¥ ìƒì„±\n        const ceiling = new THREE.Mesh(floorGeometry, ceilingMaterial);\n        ceiling.rotation.x = Math.PI / 2;\n        ceiling.position.y = 4;\n        ceiling.userData.isCeiling = true;\n        this.scene.add(ceiling);\n        \n        // ë²½ ìƒì„±\n        for (let z = 0; z < this.maze.layout.length; z++) {\n            for (let x = 0; x < this.maze.layout[z].length; x++) {\n                if (this.maze.layout[z][x] === 1) {\n                    this.createWallBlock(x, z, wallMaterial);\n                }\n            }\n        }\n    }\n    \n    /**\n     * ë²½ ë¸”ë¡ ìƒì„±\n     */\n    createWallBlock(x, z, material) {\n        const wallGeometry = new THREE.BoxGeometry(1, 3, 1);\n        const wall = new THREE.Mesh(wallGeometry, material);\n        wall.position.set(x, 1.5, z);\n        wall.castShadow = true;\n        wall.receiveShadow = true;\n        wall.userData.isWall = true;\n        wall.userData.gridPosition = { x, z };\n        \n        this.maze.walls.push(wall);\n        this.scene.add(wall);\n    }\n    \n    /**\n     * ë²½ í…ìŠ¤ì²˜ ìƒì„± (ê°„ë‹¨í•œ ì ˆì°¨ì  í…ìŠ¤ì²˜)\n     */\n    createWallTexture() {\n        const canvas = document.createElement('canvas');\n        canvas.width = 256;\n        canvas.height = 256;\n        const ctx = canvas.getContext('2d');\n        \n        // ë²½ëŒ íŒ¨í„´\n        ctx.fillStyle = '#4a4a4a';\n        ctx.fillRect(0, 0, 256, 256);\n        \n        ctx.strokeStyle = '#333';\n        ctx.lineWidth = 2;\n        \n        // ìˆ˜ì§ì„ \n        for (let i = 0; i < 256; i += 32) {\n            ctx.beginPath();\n            ctx.moveTo(i, 0);\n            ctx.lineTo(i, 256);\n            ctx.stroke();\n        }\n        \n        // ìˆ˜í‰ì„ \n        for (let i = 0; i < 256; i += 32) {\n            ctx.beginPath();\n            ctx.moveTo(0, i);\n            ctx.lineTo(256, i);\n            ctx.stroke();\n        }\n        \n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.set(1, 1);\n        \n        return texture;\n    }\n    \n    /**\n     * ë°”ë‹¥ í…ìŠ¤ì²˜ ìƒì„±\n     */\n    createFloorTexture() {\n        const canvas = document.createElement('canvas');\n        canvas.width = 256;\n        canvas.height = 256;\n        const ctx = canvas.getContext('2d');\n        \n        // ì²´í¬ë¬´ëŠ¬ íŒ¨í„´\n        for (let x = 0; x < 8; x++) {\n            for (let y = 0; y < 8; y++) {\n                ctx.fillStyle = (x + y) % 2 === 0 ? '#444' : '#333';\n                ctx.fillRect(x * 32, y * 32, 32, 32);\n            }\n        }\n        \n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.set(4, 4);\n        \n        return texture;\n    }\n    \n    /**\n     * ì‹œìŠ¤í…œë“¤ ì´ˆê¸°í™”\n     */\n    initSystems() {\n        // UI ë§¤ë‹ˆì € (ê°€ì¥ ë¨¼ì €)\n        this.uiManager = new UIManager(this);\n        \n        // í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬\n        this.playerController = new PlayerController(this.scene, this.camera, this);\n        \n        // ì „ê¸° ì´\n        this.electroGun = new ElectroGun(this.scene, this.camera, this);\n        \n        // ì  ë§¤ë‹ˆì €\n        this.enemyManager = new EnemyAI(this.scene, this);\n        \n        // ì•„ì´í…œ ë§¤ë‹ˆì €\n        this.itemManager = new ItemManager(this.scene, this);\n        \n        // ì´í™íŠ¸ ë§¤ë‹ˆì €\n        this.effectsManager = new EffectsManager(this.scene, this);\n        \n        // ì‹œìŠ¤í…œ ê°„ ì°¸ì¡° ì„¤ì •\n        this.setupSystemReferences();\n    }\n    \n    /**\n     * ì‹œìŠ¤í…œ ê°„ ì°¸ì¡° ì„¤ì •\n     */\n    setupSystemReferences() {\n        // í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ì— ì´ ì°¸ì¡° ì¶”ê°€\n        if (this.playerController && this.electroGun) {\n            this.playerController.electroGun = this.electroGun;\n        }\n        \n        // ì  ë§¤ë‹ˆì €ì— í”Œë ˆì´ì–´ ì°¸ì¡° ì¶”ê°€\n        if (this.enemyManager && this.playerController) {\n            this.enemyManager.playerController = this.playerController;\n        }\n    }\n    \n    /**\n     * ì¡°ëª… ì„¤ì •\n     */\n    setupLighting() {\n        // ì£¼ë³€ê´‘\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n        this.scene.add(ambientLight);\n        \n        // ì£¼ ë°©í–¥ê´‘\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);\n        directionalLight.position.set(10, 10, 5);\n        directionalLight.castShadow = true;\n        \n        // ê·¸ë¦¼ì ì„¤ì •\n        directionalLight.shadow.mapSize.width = 2048;\n        directionalLight.shadow.mapSize.height = 2048;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -15;\n        directionalLight.shadow.camera.right = 15;\n        directionalLight.shadow.camera.top = 15;\n        directionalLight.shadow.camera.bottom = -15;\n        \n        this.scene.add(directionalLight);\n        \n        // ë¯¸ë¡œ ì¤‘ì•™ ìŠ¤íŒŸë¼ì´íŠ¸\n        const spotLight = new THREE.SpotLight(0xffffff, 0.5, 20, Math.PI * 0.3, 0.3, 1);\n        spotLight.position.set(7.5, 8, 7.5);\n        spotLight.target.position.set(7.5, 0, 7.5);\n        spotLight.castShadow = true;\n        this.scene.add(spotLight);\n        this.scene.add(spotLight.target);\n    }\n    \n    /**\n     * ê²Œì„ ë£¨í”„ ì‹œì‘\n     */\n    startGameLoop() {\n        this.gameTimer.lastFrameTime = performance.now();\n        this.animate();\n    }\n    \n    /**\n     * ë©”ì¸ ê²Œì„ ë£¨í”„\n     */\n    animate() {\n        requestAnimationFrame(() => this.animate());\n        \n        // ë¸íƒ€ íƒ€ì„ ê³„ì‚°\n        const currentTime = performance.now();\n        this.gameTimer.deltaTime = (currentTime - this.gameTimer.lastFrameTime) / 1000;\n        this.gameTimer.lastFrameTime = currentTime;\n        this.gameTimer.currentTime += this.gameTimer.deltaTime;\n        \n        // FPS ê³„ì‚°\n        this.performance.fps = 1 / this.gameTimer.deltaTime;\n        \n        // ê²Œì„ì´ ì§„í–‰ ì¤‘ì¼ ë•Œë§Œ ì—…ë°ì´íŠ¸\n        if (this.gameState === 'playing') {\n            this.updateSystems(this.gameTimer.deltaTime);\n            this.checkWinConditions();\n            this.checkLoseConditions();\n        }\n        \n        // UIëŠ” í•­ìƒ ì—…ë°ì´íŠ¸\n        if (this.uiManager) {\n            this.uiManager.update(this.gameTimer.deltaTime);\n        }\n        \n        // ë Œë”ë§\n        this.renderer.render(this.scene, this.camera);\n    }\n    \n    /**\n     * ì‹œìŠ¤í…œë“¤ ì—…ë°ì´íŠ¸\n     */\n    updateSystems(deltaTime) {\n        // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸\n        if (this.playerController) {\n            this.playerController.update(deltaTime);\n        }\n        \n        // ì „ê¸° ì´ ì—…ë°ì´íŠ¸\n        if (this.electroGun) {\n            this.electroGun.update(deltaTime);\n        }\n        \n        // ì  ë§¤ë‹ˆì € ì—…ë°ì´íŠ¸\n        if (this.enemyManager) {\n            this.enemyManager.update(deltaTime);\n        }\n        \n        // ì•„ì´í…œ ë§¤ë‹ˆì € ì—…ë°ì´íŠ¸\n        if (this.itemManager) {\n            this.itemManager.update(deltaTime);\n        }\n        \n        // ì´í™íŠ¸ ë§¤ë‹ˆì € ì—…ë°ì´íŠ¸\n        if (this.effectsManager) {\n            this.effectsManager.update(deltaTime);\n        }\n    }\n    \n    /**\n     * ìŠ¹ë¦¬ ì¡°ê±´ ì²´í¬\n     */\n    checkWinConditions() {\n        if (!this.uiManager) return;\n        \n        const stats = this.uiManager.getState().gameStats;\n        \n        // ëª¨ë“  ì½”ì¸ ìˆ˜ì§‘í–ˆëŠ”ì§€ ì²´í¬\n        const allCoinsCollected = this.itemManager && this.itemManager.coins.length === 0;\n        \n        // ìµœì†Œ ì¡°ê±´ ë§Œì¡±í–ˆëŠ”ì§€ ì²´í¬\n        const minCoinsCollected = stats.coinsCollected >= this.winConditions.coinsRequired;\n        const minEnemiesKilled = stats.enemiesKilled >= this.winConditions.enemiesRequired;\n        \n        if (allCoinsCollected && minCoinsCollected && minEnemiesKilled) {\n            this.victory();\n        }\n    }\n    \n    /**\n     * íŒ¨ë°° ì¡°ê±´ ì²´í¬\n     */\n    checkLoseConditions() {\n        // í”Œë ˆì´ì–´ ì‚¬ë§\n        if (this.playerController && !this.playerController.isAlive) {\n            this.gameOver();\n            return;\n        }\n        \n        // ì‹œê°„ ì œí•œ (ì„ íƒì‚¬í•­)\n        if (this.winConditions.timeLimit > 0) {\n            if (this.gameTimer.currentTime > this.winConditions.timeLimit) {\n                this.gameOver();\n                return;\n            }\n        }\n    }\n    \n    /**\n     * ê²Œì„ ì‹œì‘\n     */\n    startGame() {\n        this.gameState = 'playing';\n        this.gameTimer.startTime = performance.now();\n        this.gameTimer.currentTime = 0;\n        \n        // ì‹œìŠ¤í…œë“¤ ë¦¬ì…‹\n        if (this.playerController) this.playerController.reset();\n        if (this.electroGun) this.electroGun.reset();\n        if (this.enemyManager) this.enemyManager.clearAllEnemies();\n        if (this.itemManager) this.itemManager.reset();\n        if (this.effectsManager) this.effectsManager.reset();\n        \n        console.log('ğŸš€ ê²Œì„ ì‹œì‘!');\n    }\n    \n    /**\n     * ê²Œì„ ì¼ì‹œì •ì§€\n     */\n    pauseGame() {\n        if (this.gameState === 'playing') {\n            this.gameState = 'paused';\n        }\n    }\n    \n    /**\n     * ê²Œì„ ì¬ê°œ\n     */\n    resumeGame() {\n        if (this.gameState === 'paused') {\n            this.gameState = 'playing';\n        }\n    }\n    \n    /**\n     * ê²Œì„ ì¬ì‹œì‘\n     */\n    restartGame() {\n        this.gameState = 'playing';\n        this.gameTimer.startTime = performance.now();\n        this.gameTimer.currentTime = 0;\n        \n        // ëª¨ë“  ì‹œìŠ¤í…œ ë¦¬ì…‹\n        if (this.playerController) this.playerController.reset();\n        if (this.electroGun) this.electroGun.reset();\n        if (this.enemyManager) this.enemyManager.clearAllEnemies();\n        if (this.itemManager) this.itemManager.reset();\n        if (this.effectsManager) this.effectsManager.reset();\n        if (this.uiManager) this.uiManager.resetStats();\n        \n        console.log('ğŸ”„ ê²Œì„ ì¬ì‹œì‘!');\n    }\n    \n    /**\n     * ê²Œì„ ì˜¤ë²„\n     */\n    gameOver() {\n        this.gameState = 'gameOver';\n        \n        if (this.uiManager) {\n            this.uiManager.showGameOver();\n        }\n        \n        console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„!');\n    }\n    \n    /**\n     * ìŠ¹ë¦¬\n     */\n    victory() {\n        this.gameState = 'victory';\n        \n        if (this.uiManager) {\n            this.uiManager.showVictory();\n        }\n        \n        // ìŠ¹ë¦¬ ì´í™íŠ¸\n        if (this.effectsManager) {\n            this.effectsManager.createVictoryEffect();\n        }\n        \n        console.log('ğŸ‰ ìŠ¹ë¦¬!');\n    }\n    \n    /**\n     * ë¯¸ë¡œ ì¶©ëŒ ê²€ì‚¬\n     */\n    checkMazeCollision(position, radius = 0.3) {\n        const x = Math.floor(position.x + 0.5);\n        const z = Math.floor(position.z + 0.5);\n        \n        // ê²½ê³„ ì²´í¬\n        if (x < 0 || x >= this.maze.size.width || z < 0 || z >= this.maze.size.height) {\n            return true;\n        }\n        \n        // ë²½ ì²´í¬\n        return this.maze.layout[z] && this.maze.layout[z][x] === 1;\n    }\n    \n    /**\n     * ì´ì•Œ ë²½ ì¶©ëŒ ê²€ì‚¬\n     */\n    checkBulletWallCollision(position) {\n        return this.checkMazeCollision(position, 0.1);\n    }\n    \n    /**\n     * ë¯¸ë¡œ ìœ„ì¹˜ê°€ ë²½ì¸ì§€ ì²´í¬\n     */\n    isWall(x, z) {\n        if (x < 0 || x >= this.maze.size.width || z < 0 || z >= this.maze.size.height) {\n            return true;\n        }\n        return this.maze.layout[z][x] === 1;\n    }\n    \n    /**\n     * ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬\n     */\n    onWindowResize() {\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    \n    /**\n     * ê²Œì„ ìƒíƒœ í™•ì¸\n     */\n    isPlaying() {\n        return this.gameState === 'playing';\n    }\n    \n    isPaused() {\n        return this.gameState === 'paused';\n    }\n    \n    isGameOver() {\n        return this.gameState === 'gameOver';\n    }\n    \n    isVictory() {\n        return this.gameState === 'victory';\n    }\n    \n    /**\n     * ê²Œì„ ì„¤ì • ë³€ê²½\n     */\n    updateSettings(newSettings) {\n        this.settings = { ...this.settings, ...newSettings };\n        \n        // ì„¤ì •ì— ë”°ë¥¸ ë Œë”ëŸ¬ ì—…ë°ì´íŠ¸\n        if (newSettings.shadowQuality) {\n            this.updateShadowQuality(newSettings.shadowQuality);\n        }\n        \n        if (newSettings.renderDistance) {\n            this.camera.far = newSettings.renderDistance;\n            this.camera.updateProjectionMatrix();\n            this.scene.fog.far = newSettings.renderDistance;\n        }\n    }\n    \n    /**\n     * ê·¸ë¦¼ì í’ˆì§ˆ ì—…ë°ì´íŠ¸\n     */\n    updateShadowQuality(quality) {\n        const shadowMaps = {\n            'low': 512,\n            'medium': 1024,\n            'high': 2048,\n            'ultra': 4096\n        };\n        \n        const mapSize = shadowMaps[quality] || 1024;\n        \n        this.scene.traverse((object) => {\n            if (object.isLight && object.shadow) {\n                object.shadow.mapSize.width = mapSize;\n                object.shadow.mapSize.height = mapSize;\n            }\n        });\n    }\n    \n    /**\n     * ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥\n     */\n    getDebugInfo() {\n        return {\n            gameState: this.gameState,\n            fps: Math.round(this.performance.fps),\n            gameTime: Math.round(this.gameTimer.currentTime),\n            playerPosition: this.playerController ? this.playerController.position.clone() : null,\n            enemyCount: this.enemyManager ? this.enemyManager.enemies.length : 0,\n            itemCount: this.itemManager ? this.itemManager.getState().totalItems : 0\n        };\n    }\n    \n    /**\n     * ì •ë¦¬ (ê²Œì„ ì¢…ë£Œ ì‹œ)\n     */\n    dispose() {\n        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°\n        window.removeEventListener('resize', this.onWindowResize);\n        \n        // Three.js ê°ì²´ë“¤ ì •ë¦¬\n        if (this.renderer) {\n            this.renderer.dispose();\n        }\n        \n        this.scene.traverse((object) => {\n            if (object.geometry) object.geometry.dispose();\n            if (object.material) {\n                if (Array.isArray(object.material)) {\n                    object.material.forEach(material => material.dispose());\n                } else {\n                    object.material.dispose();\n                }\n            }\n        });\n        \n        console.log('ğŸ§¹ ê²Œì„ ë§¤ë‹ˆì € ì •ë¦¬ ì™„ë£Œ');\n    }\n}