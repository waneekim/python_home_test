/**
 * EffectsManager: ê³ ê¸‰ ì‹œê°ì  íš¨ê³¼ ë° ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ
 * 
 * í•µì‹¬ ê¸°ëŠ¥:
 * - íŒŒí‹°í´ ì‹œìŠ¤í…œ
 * - ì „ê¸° ì´í™íŠ¸
 * - í­ë°œ ë° ì¶©ê²© íš¨ê³¼
 * - í™˜ê²½ ì´í™íŠ¸ (ë²ˆê°œ, ìŠ¤íŒŒí¬)
 * - ì‚¬ìš´ë“œ ê´€ë¦¬ (ì›¹ ì˜¤ë””ì˜¤ ë¯¸êµ¬í˜„ ì‹œ ì½˜ì†”)
 */
class EffectsManager {
    constructor(scene, gameManager) {
        this.scene = scene;
        this.gameManager = gameManager;
        
        // íŒŒí‹°í´ ì‹œìŠ¤í…œ
        this.particleSystems = {
            sparks: [],
            explosions: [],
            electricity: [],
            ambient: [],
            smoke: []\n        };\n        \n        // ì´í™íŠ¸ í’€ (ì„±ëŠ¥ ìµœì í™”ìš©)\n        this.effectPools = {\n            sparkParticles: [],\n            electricBolts: [],\n            explosionFragments: []\n        };\n        \n        // í™˜ê²½ ì´í™íŠ¸\n        this.environmentEffects = {\n            ambientLightning: {\n                enabled: true,\n                timer: 0,\n                interval: 10, // 10ì´ˆë§ˆë‹¤\n                duration: 0.2\n            },\n            atmosphericParticles: {\n                enabled: true,\n                particles: [],\n                count: 50\n            }\n        };\n        \n        // ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ (ì›¹ ì˜¤ë””ì˜¤ ë¯¸êµ¬í˜„ ì‹œ ì½˜ì†” ë¡œê·¸)\n        this.audioSystem = {\n            sounds: {},\n            volume: 0.7,\n            enabled: true\n        };\n        \n        // ì´í™íŠ¸ ì„¤ì •\n        this.settings = {\n            particleQuality: 'high', // 'low', 'medium', 'high'\n            maxParticles: 500,\n            electricityIntensity: 1.0,\n            explosionScale: 1.0\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        this.setupParticleMaterials();\n        this.createAmbientEffects();\n        this.preloadSounds();\n    }\n    \n    /**\n     * íŒŒí‹°í´ ì¬ë£Œ ì„¤ì •\n     */\n    setupParticleMaterials() {\n        // ìŠ¤íŒŒí¬ ì¬ë£Œ\n        this.materials = {\n            spark: new THREE.PointsMaterial({\n                color: 0xFFD700,\n                size: 0.1,\n                transparent: true,\n                opacity: 0.8,\n                blending: THREE.AdditiveBlending\n            }),\n            \n            electricity: new THREE.LineBasicMaterial({\n                color: 0x00FFFF,\n                transparent: true,\n                opacity: 0.9,\n                linewidth: 3\n            }),\n            \n            explosion: new THREE.PointsMaterial({\n                color: 0xFF4444,\n                size: 0.2,\n                transparent: true,\n                opacity: 1.0,\n                blending: THREE.AdditiveBlending\n            }),\n            \n            smoke: new THREE.PointsMaterial({\n                color: 0x444444,\n                size: 0.5,\n                transparent: true,\n                opacity: 0.3,\n                blending: THREE.NormalBlending\n            })\n        };\n    }\n    \n    /**\n     * ì£¼ë³€ í™˜ê²½ ì´í™íŠ¸ ìƒì„±\n     */\n    createAmbientEffects() {\n        if (this.environmentEffects.atmosphericParticles.enabled) {\n            this.createAtmosphericParticles();\n        }\n    }\n    \n    /**\n     * ëŒ€ê¸° ì¤‘ ë– ë‹¤ë‹ˆëŠ” íŒŒí‹°í´ ìƒì„±\n     */\n    createAtmosphericParticles() {\n        const particleCount = this.environmentEffects.atmosphericParticles.count;\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(particleCount * 3);\n        const colors = new Float32Array(particleCount * 3);\n        \n        for (let i = 0; i < particleCount * 3; i += 3) {\n            positions[i] = (Math.random() - 0.5) * 30; // x\n            positions[i + 1] = Math.random() * 10; // y\n            positions[i + 2] = (Math.random() - 0.5) * 30; // z\n            \n            // ëœë¤ ìƒ‰ìƒ (ì–´ë‘¡ê³  ì‹ ë¹„ë¡œìš´ í†¤)\n            const intensity = 0.1 + Math.random() * 0.3;\n            colors[i] = intensity; // r\n            colors[i + 1] = intensity * 1.5; // g\n            colors[i + 2] = intensity * 2; // b\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n        \n        const material = new THREE.PointsMaterial({\n            size: 0.02,\n            transparent: true,\n            opacity: 0.6,\n            vertexColors: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        const particles = new THREE.Points(geometry, material);\n        this.scene.add(particles);\n        \n        this.environmentEffects.atmosphericParticles.particles.push({\n            mesh: particles,\n            originalPositions: positions.slice(),\n            time: 0\n        });\n    }\n    \n    /**\n     * ì‚¬ìš´ë“œ ë¯¸ë¦¬ ë¡œë“œ\n     */\n    preloadSounds() {\n        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ\n        this.audioSystem.sounds = {\n            electricShot: 'electric_shot.mp3',\n            explosion: 'explosion.mp3',\n            spark: 'spark.mp3',\n            powerUp: 'power_up.mp3',\n            coinCollect: 'coin_collect.mp3',\n            enemyHit: 'enemy_hit.mp3',\n            playerHit: 'player_hit.mp3',\n            ambientHum: 'ambient_hum.mp3'\n        };\n    }\n    \n    /**\n     * ë©”ì¸ ì—…ë°ì´íŠ¸\n     */\n    update(deltaTime) {\n        this.updateParticleSystems(deltaTime);\n        this.updateEnvironmentEffects(deltaTime);\n        this.cleanupEffects();\n    }\n    \n    /**\n     * íŒŒí‹°í´ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸\n     */\n    updateParticleSystems(deltaTime) {\n        // ìŠ¤íŒŒí¬ ì—…ë°ì´íŠ¸\n        this.updateSparks(deltaTime);\n        \n        // í­ë°œ ì—…ë°ì´íŠ¸\n        this.updateExplosions(deltaTime);\n        \n        // ì „ê¸° ì´í™íŠ¸ ì—…ë°ì´íŠ¸\n        this.updateElectricity(deltaTime);\n        \n        // ì—°ê¸° ì—…ë°ì´íŠ¸\n        this.updateSmoke(deltaTime);\n    }\n    \n    /**\n     * í™˜ê²½ ì´í™íŠ¸ ì—…ë°ì´íŠ¸\n     */\n    updateEnvironmentEffects(deltaTime) {\n        // ì£¼ë³€ ë²ˆê°œ\n        this.updateAmbientLightning(deltaTime);\n        \n        // ëŒ€ê¸° íŒŒí‹°í´\n        this.updateAtmosphericParticles(deltaTime);\n    }\n    \n    /**\n     * ìŠ¤íŒŒí¬ ì—…ë°ì´íŠ¸\n     */\n    updateSparks(deltaTime) {\n        for (let i = this.particleSystems.sparks.length - 1; i >= 0; i--) {\n            const spark = this.particleSystems.sparks[i];\n            \n            // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸\n            spark.velocity.y -= 9.8 * deltaTime; // ì¤‘ë ¥\n            spark.position.add(spark.velocity.clone().multiplyScalar(deltaTime));\n            \n            // ìƒëª… ê°ì†Œ\n            spark.life -= deltaTime;\n            \n            // í˜ì´ë“œ ì•„ì›ƒ\n            if (spark.mesh) {\n                spark.mesh.material.opacity = spark.life / spark.maxLife;\n                spark.mesh.position.copy(spark.position);\n            }\n            \n            // ìƒëª… ëë‚˜ë©´ ì œê±°\n            if (spark.life <= 0) {\n                if (spark.mesh) {\n                    this.scene.remove(spark.mesh);\n                }\n                this.particleSystems.sparks.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * í­ë°œ ì—…ë°ì´íŠ¸\n     */\n    updateExplosions(deltaTime) {\n        for (let i = this.particleSystems.explosions.length - 1; i >= 0; i--) {\n            const explosion = this.particleSystems.explosions[i];\n            \n            explosion.time += deltaTime;\n            const progress = explosion.time / explosion.duration;\n            \n            if (explosion.mesh) {\n                // í™•ì¥ ì• ë‹ˆë©”ì´ì…˜\n                const scale = 1 + progress * explosion.maxScale;\n                explosion.mesh.scale.setScalar(scale);\n                \n                // í˜ì´ë“œ ì•„ì›ƒ\n                explosion.mesh.material.opacity = 1 - progress;\n            }\n            \n            // ì™„ë£Œë˜ë©´ ì œê±°\n            if (progress >= 1) {\n                if (explosion.mesh) {\n                    this.scene.remove(explosion.mesh);\n                }\n                this.particleSystems.explosions.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * ì „ê¸° ì´í™íŠ¸ ì—…ë°ì´íŠ¸\n     */\n    updateElectricity(deltaTime) {\n        for (let i = this.particleSystems.electricity.length - 1; i >= 0; i--) {\n            const bolt = this.particleSystems.electricity[i];\n            \n            bolt.time += deltaTime;\n            const progress = bolt.time / bolt.duration;\n            \n            if (bolt.mesh) {\n                // ë²ˆê°œ ê¹œë¹¡ì„ íš¨ê³¼\n                const flicker = Math.sin(bolt.time * 20) * 0.5 + 0.5;\n                bolt.mesh.material.opacity = (1 - progress) * flicker;\n                \n                // ëœë¤í•œ ì§€ê·¸ì¬ê·¸ ì›€ì§ì„\n                if (bolt.segments) {\n                    this.updateLightningSegments(bolt);\n                }\n            }\n            \n            // ì™„ë£Œë˜ë©´ ì œê±°\n            if (progress >= 1) {\n                if (bolt.mesh) {\n                    this.scene.remove(bolt.mesh);\n                }\n                this.particleSystems.electricity.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * ì—°ê¸° ì—…ë°ì´íŠ¸\n     */\n    updateSmoke(deltaTime) {\n        for (let i = this.particleSystems.smoke.length - 1; i >= 0; i--) {\n            const smoke = this.particleSystems.smoke[i];\n            \n            // ìœ„ë¡œ ì˜¬ë¼ê°€ë©´ì„œ í™•ì‚°\n            smoke.velocity.y += 2 * deltaTime;\n            smoke.velocity.x += (Math.random() - 0.5) * deltaTime;\n            smoke.velocity.z += (Math.random() - 0.5) * deltaTime;\n            \n            smoke.position.add(smoke.velocity.clone().multiplyScalar(deltaTime));\n            smoke.life -= deltaTime;\n            \n            if (smoke.mesh) {\n                smoke.mesh.position.copy(smoke.position);\n                smoke.mesh.material.opacity = (smoke.life / smoke.maxLife) * 0.3;\n                \n                // í¬ê¸° ì¦ê°€\n                const scale = 1 + (1 - smoke.life / smoke.maxLife) * 2;\n                smoke.mesh.scale.setScalar(scale);\n            }\n            \n            if (smoke.life <= 0) {\n                if (smoke.mesh) {\n                    this.scene.remove(smoke.mesh);\n                }\n                this.particleSystems.smoke.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * ì£¼ë³€ ë²ˆê°œ ì—…ë°ì´íŠ¸\n     */\n    updateAmbientLightning(deltaTime) {\n        const lightning = this.environmentEffects.ambientLightning;\n        \n        if (!lightning.enabled) return;\n        \n        lightning.timer += deltaTime;\n        \n        if (lightning.timer >= lightning.interval) {\n            lightning.timer = 0;\n            this.createAmbientLightning();\n        }\n    }\n    \n    /**\n     * ëŒ€ê¸° íŒŒí‹°í´ ì—…ë°ì´íŠ¸\n     */\n    updateAtmosphericParticles(deltaTime) {\n        this.environmentEffects.atmosphericParticles.particles.forEach(particleSystem => {\n            particleSystem.time += deltaTime;\n            \n            const positions = particleSystem.mesh.geometry.attributes.position.array;\n            const originalPositions = particleSystem.originalPositions;\n            \n            for (let i = 0; i < positions.length; i += 3) {\n                // ë¶€ë“œëŸ¬ìš´ ë– ë‹¤ë‹ˆëŠ” ì›€ì§ì„\n                positions[i] = originalPositions[i] + Math.sin(particleSystem.time + i) * 0.5;\n                positions[i + 1] = originalPositions[i + 1] + Math.cos(particleSystem.time * 0.5 + i) * 0.3;\n                positions[i + 2] = originalPositions[i + 2] + Math.sin(particleSystem.time * 0.3 + i) * 0.4;\n            }\n            \n            particleSystem.mesh.geometry.attributes.position.needsUpdate = true;\n        });\n    }\n    \n    /**\n     * ìŠ¤íŒŒí¬ ìƒì„±\n     */\n    createSparks(position, count = 10, color = 0xFFD700) {\n        for (let i = 0; i < count; i++) {\n            const sparkGeometry = new THREE.SphereGeometry(0.02, 4, 4);\n            const sparkMaterial = new THREE.MeshBasicMaterial({ \n                color: color,\n                transparent: true,\n                opacity: 1\n            });\n            \n            const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);\n            spark.position.copy(position);\n            \n            const sparkData = {\n                mesh: spark,\n                position: position.clone(),\n                velocity: new THREE.Vector3(\n                    (Math.random() - 0.5) * 6,\n                    Math.random() * 4 + 2,\n                    (Math.random() - 0.5) * 6\n                ),\n                life: 0.5 + Math.random() * 0.5,\n                maxLife: 1.0\n            };\n            \n            sparkData.maxLife = sparkData.life;\n            \n            this.particleSystems.sparks.push(sparkData);\n            this.scene.add(spark);\n        }\n        \n        this.playSound('spark');\n    }\n    \n    /**\n     * í­ë°œ ìƒì„±\n     */\n    createExplosion(position, scale = 1.0, color = 0xFF4444) {\n        // ë©”ì¸ í­ë°œ êµ¬\n        const explosionGeometry = new THREE.SphereGeometry(0.5, 8, 6);\n        const explosionMaterial = new THREE.MeshBasicMaterial({ \n            color: color,\n            transparent: true,\n            opacity: 1\n        });\n        \n        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);\n        explosion.position.copy(position);\n        \n        const explosionData = {\n            mesh: explosion,\n            time: 0,\n            duration: 0.8,\n            maxScale: scale * 3\n        };\n        \n        this.particleSystems.explosions.push(explosionData);\n        this.scene.add(explosion);\n        \n        // í­ë°œ ìŠ¤íŒŒí¬\n        this.createSparks(position, 20, 0xFF6666);\n        \n        // í­ë°œ ì—°ê¸°\n        this.createSmoke(position, 5);\n        \n        this.playSound('explosion');\n    }\n    \n    /**\n     * ì „ê¸° ë³¼íŠ¸ ìƒì„± (ë‘ ì  ì‚¬ì´)\n     */\n    createElectricBolt(startPos, endPos, segments = 8, color = 0x00FFFF) {\n        const points = this.generateLightningPath(startPos, endPos, segments);\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\n        const material = this.materials.electricity.clone();\n        material.color.setHex(color);\n        \n        const bolt = new THREE.Line(geometry, material);\n        \n        const boltData = {\n            mesh: bolt,\n            segments: points,\n            time: 0,\n            duration: 0.3\n        };\n        \n        this.particleSystems.electricity.push(boltData);\n        this.scene.add(bolt);\n        \n        this.playSound('electricShot');\n    }\n    \n    /**\n     * ë²ˆê°œ ê²½ë¡œ ìƒì„± (ì§€ê·¸ì¬ê·¸)\n     */\n    generateLightningPath(start, end, segments) {\n        const points = [start.clone()];\n        \n        for (let i = 1; i < segments; i++) {\n            const progress = i / segments;\n            const point = start.clone().lerp(end, progress);\n            \n            // ëœë¤ ì˜¤í”„ì…‹ ì¶”ê°€\n            point.add(new THREE.Vector3(\n                (Math.random() - 0.5) * 0.5,\n                (Math.random() - 0.5) * 0.5,\n                (Math.random() - 0.5) * 0.5\n            ));\n            \n            points.push(point);\n        }\n        \n        points.push(end.clone());\n        return points;\n    }\n    \n    /**\n     * ë²ˆê°œ ì„¸ê·¸ë¨¼íŠ¸ ì—…ë°ì´íŠ¸ (ê¹œë¹¡ì„)\n     */\n    updateLightningSegments(bolt) {\n        const positions = bolt.mesh.geometry.attributes.position.array;\n        \n        for (let i = 3; i < positions.length - 3; i += 3) {\n            // ì¤‘ê°„ ì ë“¤ì— ëœë¤ ì§€í„° ì¶”ê°€\n            positions[i] += (Math.random() - 0.5) * 0.1;\n            positions[i + 1] += (Math.random() - 0.5) * 0.1;\n            positions[i + 2] += (Math.random() - 0.5) * 0.1;\n        }\n        \n        bolt.mesh.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    /**\n     * ì—°ê¸° ìƒì„±\n     */\n    createSmoke(position, count = 5) {\n        for (let i = 0; i < count; i++) {\n            const smokeGeometry = new THREE.SphereGeometry(0.2, 6, 4);\n            const smokeMaterial = this.materials.smoke.clone();\n            \n            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);\n            smoke.position.copy(position);\n            smoke.position.add(new THREE.Vector3(\n                (Math.random() - 0.5) * 0.5,\n                0,\n                (Math.random() - 0.5) * 0.5\n            ));\n            \n            const smokeData = {\n                mesh: smoke,\n                position: smoke.position.clone(),\n                velocity: new THREE.Vector3(\n                    (Math.random() - 0.5) * 1,\n                    1 + Math.random(),\n                    (Math.random() - 0.5) * 1\n                ),\n                life: 2 + Math.random() * 2,\n                maxLife: 4\n            };\n            \n            smokeData.maxLife = smokeData.life;\n            \n            this.particleSystems.smoke.push(smokeData);\n            this.scene.add(smoke);\n        }\n    }\n    \n    /**\n     * ì£¼ë³€ ë²ˆê°œ ìƒì„±\n     */\n    createAmbientLightning() {\n        // ë¯¸ë¡œ ìƒê³µì— ë²ˆê°œ ìƒì„±\n        const startPos = new THREE.Vector3(\n            Math.random() * 15,\n            8 + Math.random() * 2,\n            Math.random() * 15\n        );\n        \n        const endPos = new THREE.Vector3(\n            startPos.x + (Math.random() - 0.5) * 5,\n            startPos.y - 2 - Math.random() * 3,\n            startPos.z + (Math.random() - 0.5) * 5\n        );\n        \n        this.createElectricBolt(startPos, endPos, 12, 0x4444FF);\n        \n        // ë²ˆê°œì™€ í•¨ê»˜ ì ê¹ ë°ì•„ì§€ëŠ” íš¨ê³¼\n        const flash = new THREE.PointLight(0x4444FF, 2, 20);\n        flash.position.copy(startPos);\n        this.scene.add(flash);\n        \n        setTimeout(() => {\n            this.scene.remove(flash);\n        }, 200);\n    }\n    \n    /**\n     * ìŠ¹ë¦¬ ì´í™íŠ¸\n     */\n    createVictoryEffect() {\n        // ë¯¸ë¡œ ì¤‘ì•™ì—ì„œ ëŒ€í˜• ì „ê¸° í­ë°œ\n        const centerPos = new THREE.Vector3(7.5, 2, 7.5);\n        \n        // ì—¬ëŸ¬ ë‹¨ê³„ í­ë°œ\n        setTimeout(() => this.createExplosion(centerPos, 2.0, 0xFFD700), 0);\n        setTimeout(() => this.createExplosion(centerPos, 3.0, 0x00FFFF), 300);\n        setTimeout(() => this.createExplosion(centerPos, 4.0, 0xFF66FF), 600);\n        \n        // ì£¼ë³€ìœ¼ë¡œ ë²ˆê°œ ìƒì„±\n        for (let i = 0; i < 8; i++) {\n            setTimeout(() => {\n                const angle = (i / 8) * Math.PI * 2;\n                const targetPos = new THREE.Vector3(\n                    centerPos.x + Math.cos(angle) * 5,\n                    centerPos.y,\n                    centerPos.z + Math.sin(angle) * 5\n                );\n                this.createElectricBolt(centerPos, targetPos, 10, 0xFFD700);\n            }, i * 100);\n        }\n    }\n    \n    /**\n     * ì´ ë°œì‚¬ ì´í™íŠ¸\n     */\n    createGunFireEffect(position, direction) {\n        // ì´êµ¬ ì„¬ê´‘\n        const muzzlePos = position.clone().add(direction.clone().multiplyScalar(0.3));\n        this.createSparks(muzzlePos, 5, 0x00FFFF);\n        \n        // ì´êµ¬ ì—°ê¸°\n        this.createSmoke(muzzlePos, 2);\n    }\n    \n    /**\n     * ì  í”¼ê²© ì´í™íŠ¸\n     */\n    createEnemyHitEffect(position) {\n        this.createSparks(position, 8, 0xFF4444);\n        this.createElectricBolt(\n            position,\n            position.clone().add(new THREE.Vector3(0, 1, 0)),\n            5,\n            0xFF6666\n        );\n        this.playSound('enemyHit');\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ í”¼ê²© ì´í™íŠ¸\n     */\n    createPlayerHitEffect(position) {\n        this.createSparks(position, 6, 0xFF0000);\n        this.playSound('playerHit');\n    }\n    \n    /**\n     * ì•„ì´í…œ ìˆ˜ì§‘ ì´í™íŠ¸\n     */\n    createItemCollectEffect(position, itemType) {\n        const colors = {\n            'COIN': 0xFFD700,\n            'POWER_CUBE': 0x00FFFF,\n            'HEALTH_PACK': 0xFF6B6B,\n            'SPEED_BOOST': 0x00FF00,\n            'SHIELD': 0x4169E1\n        };\n        \n        const color = colors[itemType] || 0xFFFFFF;\n        \n        this.createSparks(position, 15, color);\n        \n        // ìƒìŠ¹í•˜ëŠ” ë§ ì´í™íŠ¸\n        this.createRisingRing(position, color);\n        \n        this.playSound('coinCollect');\n    }\n    \n    /**\n     * ìƒìŠ¹í•˜ëŠ” ë§ ì´í™íŠ¸\n     */\n    createRisingRing(position, color) {\n        const ringGeometry = new THREE.RingGeometry(0.1, 0.3, 16);\n        const ringMaterial = new THREE.MeshBasicMaterial({ \n            color: color,\n            transparent: true,\n            opacity: 0.8,\n            side: THREE.DoubleSide\n        });\n        \n        const ring = new THREE.Mesh(ringGeometry, ringMaterial);\n        ring.position.copy(position);\n        ring.rotation.x = -Math.PI / 2;\n        \n        this.scene.add(ring);\n        \n        // ì• ë‹ˆë©”ì´ì…˜\n        const startTime = performance.now();\n        const duration = 1000;\n        \n        const animateRing = () => {\n            const elapsed = performance.now() - startTime;\n            const progress = elapsed / duration;\n            \n            if (progress < 1) {\n                ring.position.y = position.y + progress * 2;\n                ring.scale.setScalar(1 + progress * 2);\n                ring.material.opacity = 0.8 * (1 - progress);\n                requestAnimationFrame(animateRing);\n            } else {\n                this.scene.remove(ring);\n            }\n        };\n        \n        animateRing();\n    }\n    \n    /**\n     * ì‚¬ìš´ë“œ ì¬ìƒ\n     */\n    playSound(soundName, volume = 1.0) {\n        if (!this.audioSystem.enabled) return;\n        \n        console.log(`ğŸ”Š [${soundName}] ì‚¬ìš´ë“œ ì¬ìƒ (ë³¼ë¥¨: ${volume * this.audioSystem.volume})`);\n        \n        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì›¹ ì˜¤ë””ì˜¤ API ì‚¬ìš©\n        /*\n        if (this.audioSystem.sounds[soundName]) {\n            const audio = new Audio(this.audioSystem.sounds[soundName]);\n            audio.volume = volume * this.audioSystem.volume;\n            audio.play().catch(e => console.warn('ì˜¤ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨:', e));\n        }\n        */\n    }\n    \n    /**\n     * ì´í™íŠ¸ ì •ë¦¬\n     */\n    cleanupEffects() {\n        // íŒŒí‹°í´ ìˆ˜ ì œí•œ\n        const totalParticles = \n            this.particleSystems.sparks.length +\n            this.particleSystems.explosions.length +\n            this.particleSystems.electricity.length +\n            this.particleSystems.smoke.length;\n        \n        if (totalParticles > this.settings.maxParticles) {\n            // ì˜¤ë˜ëœ íŒŒí‹°í´ë¶€í„° ì œê±°\n            this.removeOldestParticles();\n        }\n    }\n    \n    /**\n     * ê°€ì¥ ì˜¤ë˜ëœ íŒŒí‹°í´ ì œê±°\n     */\n    removeOldestParticles() {\n        const systems = ['sparks', 'explosions', 'electricity', 'smoke'];\n        \n        systems.forEach(systemName => {\n            const system = this.particleSystems[systemName];\n            if (system.length > 0) {\n                const oldest = system.shift();\n                if (oldest && oldest.mesh) {\n                    this.scene.remove(oldest.mesh);\n                }\n            }\n        });\n    }\n    \n    /**\n     * ëª¨ë“  ì´í™íŠ¸ ì •ë¦¬ (ë¦¬ì…‹ ì‹œ)\n     */\n    reset() {\n        // ëª¨ë“  íŒŒí‹°í´ ì‹œìŠ¤í…œ ì •ë¦¬\n        Object.values(this.particleSystems).forEach(system => {\n            system.forEach(effect => {\n                if (effect.mesh) {\n                    this.scene.remove(effect.mesh);\n                }\n            });\n            system.length = 0;\n        });\n        \n        console.log('âœ¨ ì´í™íŠ¸ ì‹œìŠ¤í…œ ë¦¬ì…‹');\n    }\n    \n    /**\n     * ì„¤ì • ì—…ë°ì´íŠ¸\n     */\n    updateSettings(newSettings) {\n        this.settings = { ...this.settings, ...newSettings };\n        \n        // í’ˆì§ˆ ì„¤ì •ì— ë”°ë¥¸ íŒŒí‹°í´ ìˆ˜ ì¡°ì •\n        const qualityMultipliers = {\n            'low': 0.3,\n            'medium': 0.7,\n            'high': 1.0\n        };\n        \n        const multiplier = qualityMultipliers[this.settings.particleQuality] || 1.0;\n        this.settings.maxParticles = Math.floor(500 * multiplier);\n        this.environmentEffects.atmosphericParticles.count = Math.floor(50 * multiplier);\n    }\n    \n    /**\n     * í˜„ì¬ ìƒíƒœ ë°˜í™˜\n     */\n    getState() {\n        const totalEffects = Object.values(this.particleSystems)\n            .reduce((sum, system) => sum + system.length, 0);\n        \n        return {\n            totalEffects,\n            maxEffects: this.settings.maxParticles,\n            particleQuality: this.settings.particleQuality,\n            audioEnabled: this.audioSystem.enabled\n        };\n    }\n}