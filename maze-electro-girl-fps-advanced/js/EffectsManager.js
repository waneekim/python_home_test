/**
 * EffectsManager: 고급 시각적 효과 및 사운드 시스템
 * 
 * 핵심 기능:
 * - 파티클 시스템
 * - 전기 이펙트
 * - 폭발 및 충격 효과
 * - 환경 이펙트 (번개, 스파크)
 * - 사운드 관리 (웹 오디오 미구현 시 콘솔)
 */
class EffectsManager {
    constructor(scene, gameManager) {
        this.scene = scene;
        this.gameManager = gameManager;
        
        // 파티클 시스템
        this.particleSystems = {
            sparks: [],
            explosions: [],
            electricity: [],
            ambient: [],
            smoke: []\n        };\n        \n        // 이펙트 풀 (성능 최적화용)\n        this.effectPools = {\n            sparkParticles: [],\n            electricBolts: [],\n            explosionFragments: []\n        };\n        \n        // 환경 이펙트\n        this.environmentEffects = {\n            ambientLightning: {\n                enabled: true,\n                timer: 0,\n                interval: 10, // 10초마다\n                duration: 0.2\n            },\n            atmosphericParticles: {\n                enabled: true,\n                particles: [],\n                count: 50\n            }\n        };\n        \n        // 오디오 시스템 (웹 오디오 미구현 시 콘솔 로그)\n        this.audioSystem = {\n            sounds: {},\n            volume: 0.7,\n            enabled: true\n        };\n        \n        // 이펙트 설정\n        this.settings = {\n            particleQuality: 'high', // 'low', 'medium', 'high'\n            maxParticles: 500,\n            electricityIntensity: 1.0,\n            explosionScale: 1.0\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        this.setupParticleMaterials();\n        this.createAmbientEffects();\n        this.preloadSounds();\n    }\n    \n    /**\n     * 파티클 재료 설정\n     */\n    setupParticleMaterials() {\n        // 스파크 재료\n        this.materials = {\n            spark: new THREE.PointsMaterial({\n                color: 0xFFD700,\n                size: 0.1,\n                transparent: true,\n                opacity: 0.8,\n                blending: THREE.AdditiveBlending\n            }),\n            \n            electricity: new THREE.LineBasicMaterial({\n                color: 0x00FFFF,\n                transparent: true,\n                opacity: 0.9,\n                linewidth: 3\n            }),\n            \n            explosion: new THREE.PointsMaterial({\n                color: 0xFF4444,\n                size: 0.2,\n                transparent: true,\n                opacity: 1.0,\n                blending: THREE.AdditiveBlending\n            }),\n            \n            smoke: new THREE.PointsMaterial({\n                color: 0x444444,\n                size: 0.5,\n                transparent: true,\n                opacity: 0.3,\n                blending: THREE.NormalBlending\n            })\n        };\n    }\n    \n    /**\n     * 주변 환경 이펙트 생성\n     */\n    createAmbientEffects() {\n        if (this.environmentEffects.atmosphericParticles.enabled) {\n            this.createAtmosphericParticles();\n        }\n    }\n    \n    /**\n     * 대기 중 떠다니는 파티클 생성\n     */\n    createAtmosphericParticles() {\n        const particleCount = this.environmentEffects.atmosphericParticles.count;\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(particleCount * 3);\n        const colors = new Float32Array(particleCount * 3);\n        \n        for (let i = 0; i < particleCount * 3; i += 3) {\n            positions[i] = (Math.random() - 0.5) * 30; // x\n            positions[i + 1] = Math.random() * 10; // y\n            positions[i + 2] = (Math.random() - 0.5) * 30; // z\n            \n            // 랜덤 색상 (어둡고 신비로운 톤)\n            const intensity = 0.1 + Math.random() * 0.3;\n            colors[i] = intensity; // r\n            colors[i + 1] = intensity * 1.5; // g\n            colors[i + 2] = intensity * 2; // b\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n        \n        const material = new THREE.PointsMaterial({\n            size: 0.02,\n            transparent: true,\n            opacity: 0.6,\n            vertexColors: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        const particles = new THREE.Points(geometry, material);\n        this.scene.add(particles);\n        \n        this.environmentEffects.atmosphericParticles.particles.push({\n            mesh: particles,\n            originalPositions: positions.slice(),\n            time: 0\n        });\n    }\n    \n    /**\n     * 사운드 미리 로드\n     */\n    preloadSounds() {\n        // 실제 구현에서는 오디오 파일 로드\n        this.audioSystem.sounds = {\n            electricShot: 'electric_shot.mp3',\n            explosion: 'explosion.mp3',\n            spark: 'spark.mp3',\n            powerUp: 'power_up.mp3',\n            coinCollect: 'coin_collect.mp3',\n            enemyHit: 'enemy_hit.mp3',\n            playerHit: 'player_hit.mp3',\n            ambientHum: 'ambient_hum.mp3'\n        };\n    }\n    \n    /**\n     * 메인 업데이트\n     */\n    update(deltaTime) {\n        this.updateParticleSystems(deltaTime);\n        this.updateEnvironmentEffects(deltaTime);\n        this.cleanupEffects();\n    }\n    \n    /**\n     * 파티클 시스템 업데이트\n     */\n    updateParticleSystems(deltaTime) {\n        // 스파크 업데이트\n        this.updateSparks(deltaTime);\n        \n        // 폭발 업데이트\n        this.updateExplosions(deltaTime);\n        \n        // 전기 이펙트 업데이트\n        this.updateElectricity(deltaTime);\n        \n        // 연기 업데이트\n        this.updateSmoke(deltaTime);\n    }\n    \n    /**\n     * 환경 이펙트 업데이트\n     */\n    updateEnvironmentEffects(deltaTime) {\n        // 주변 번개\n        this.updateAmbientLightning(deltaTime);\n        \n        // 대기 파티클\n        this.updateAtmosphericParticles(deltaTime);\n    }\n    \n    /**\n     * 스파크 업데이트\n     */\n    updateSparks(deltaTime) {\n        for (let i = this.particleSystems.sparks.length - 1; i >= 0; i--) {\n            const spark = this.particleSystems.sparks[i];\n            \n            // 물리 업데이트\n            spark.velocity.y -= 9.8 * deltaTime; // 중력\n            spark.position.add(spark.velocity.clone().multiplyScalar(deltaTime));\n            \n            // 생명 감소\n            spark.life -= deltaTime;\n            \n            // 페이드 아웃\n            if (spark.mesh) {\n                spark.mesh.material.opacity = spark.life / spark.maxLife;\n                spark.mesh.position.copy(spark.position);\n            }\n            \n            // 생명 끝나면 제거\n            if (spark.life <= 0) {\n                if (spark.mesh) {\n                    this.scene.remove(spark.mesh);\n                }\n                this.particleSystems.sparks.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * 폭발 업데이트\n     */\n    updateExplosions(deltaTime) {\n        for (let i = this.particleSystems.explosions.length - 1; i >= 0; i--) {\n            const explosion = this.particleSystems.explosions[i];\n            \n            explosion.time += deltaTime;\n            const progress = explosion.time / explosion.duration;\n            \n            if (explosion.mesh) {\n                // 확장 애니메이션\n                const scale = 1 + progress * explosion.maxScale;\n                explosion.mesh.scale.setScalar(scale);\n                \n                // 페이드 아웃\n                explosion.mesh.material.opacity = 1 - progress;\n            }\n            \n            // 완료되면 제거\n            if (progress >= 1) {\n                if (explosion.mesh) {\n                    this.scene.remove(explosion.mesh);\n                }\n                this.particleSystems.explosions.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * 전기 이펙트 업데이트\n     */\n    updateElectricity(deltaTime) {\n        for (let i = this.particleSystems.electricity.length - 1; i >= 0; i--) {\n            const bolt = this.particleSystems.electricity[i];\n            \n            bolt.time += deltaTime;\n            const progress = bolt.time / bolt.duration;\n            \n            if (bolt.mesh) {\n                // 번개 깜빡임 효과\n                const flicker = Math.sin(bolt.time * 20) * 0.5 + 0.5;\n                bolt.mesh.material.opacity = (1 - progress) * flicker;\n                \n                // 랜덤한 지그재그 움직임\n                if (bolt.segments) {\n                    this.updateLightningSegments(bolt);\n                }\n            }\n            \n            // 완료되면 제거\n            if (progress >= 1) {\n                if (bolt.mesh) {\n                    this.scene.remove(bolt.mesh);\n                }\n                this.particleSystems.electricity.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * 연기 업데이트\n     */\n    updateSmoke(deltaTime) {\n        for (let i = this.particleSystems.smoke.length - 1; i >= 0; i--) {\n            const smoke = this.particleSystems.smoke[i];\n            \n            // 위로 올라가면서 확산\n            smoke.velocity.y += 2 * deltaTime;\n            smoke.velocity.x += (Math.random() - 0.5) * deltaTime;\n            smoke.velocity.z += (Math.random() - 0.5) * deltaTime;\n            \n            smoke.position.add(smoke.velocity.clone().multiplyScalar(deltaTime));\n            smoke.life -= deltaTime;\n            \n            if (smoke.mesh) {\n                smoke.mesh.position.copy(smoke.position);\n                smoke.mesh.material.opacity = (smoke.life / smoke.maxLife) * 0.3;\n                \n                // 크기 증가\n                const scale = 1 + (1 - smoke.life / smoke.maxLife) * 2;\n                smoke.mesh.scale.setScalar(scale);\n            }\n            \n            if (smoke.life <= 0) {\n                if (smoke.mesh) {\n                    this.scene.remove(smoke.mesh);\n                }\n                this.particleSystems.smoke.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * 주변 번개 업데이트\n     */\n    updateAmbientLightning(deltaTime) {\n        const lightning = this.environmentEffects.ambientLightning;\n        \n        if (!lightning.enabled) return;\n        \n        lightning.timer += deltaTime;\n        \n        if (lightning.timer >= lightning.interval) {\n            lightning.timer = 0;\n            this.createAmbientLightning();\n        }\n    }\n    \n    /**\n     * 대기 파티클 업데이트\n     */\n    updateAtmosphericParticles(deltaTime) {\n        this.environmentEffects.atmosphericParticles.particles.forEach(particleSystem => {\n            particleSystem.time += deltaTime;\n            \n            const positions = particleSystem.mesh.geometry.attributes.position.array;\n            const originalPositions = particleSystem.originalPositions;\n            \n            for (let i = 0; i < positions.length; i += 3) {\n                // 부드러운 떠다니는 움직임\n                positions[i] = originalPositions[i] + Math.sin(particleSystem.time + i) * 0.5;\n                positions[i + 1] = originalPositions[i + 1] + Math.cos(particleSystem.time * 0.5 + i) * 0.3;\n                positions[i + 2] = originalPositions[i + 2] + Math.sin(particleSystem.time * 0.3 + i) * 0.4;\n            }\n            \n            particleSystem.mesh.geometry.attributes.position.needsUpdate = true;\n        });\n    }\n    \n    /**\n     * 스파크 생성\n     */\n    createSparks(position, count = 10, color = 0xFFD700) {\n        for (let i = 0; i < count; i++) {\n            const sparkGeometry = new THREE.SphereGeometry(0.02, 4, 4);\n            const sparkMaterial = new THREE.MeshBasicMaterial({ \n                color: color,\n                transparent: true,\n                opacity: 1\n            });\n            \n            const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);\n            spark.position.copy(position);\n            \n            const sparkData = {\n                mesh: spark,\n                position: position.clone(),\n                velocity: new THREE.Vector3(\n                    (Math.random() - 0.5) * 6,\n                    Math.random() * 4 + 2,\n                    (Math.random() - 0.5) * 6\n                ),\n                life: 0.5 + Math.random() * 0.5,\n                maxLife: 1.0\n            };\n            \n            sparkData.maxLife = sparkData.life;\n            \n            this.particleSystems.sparks.push(sparkData);\n            this.scene.add(spark);\n        }\n        \n        this.playSound('spark');\n    }\n    \n    /**\n     * 폭발 생성\n     */\n    createExplosion(position, scale = 1.0, color = 0xFF4444) {\n        // 메인 폭발 구\n        const explosionGeometry = new THREE.SphereGeometry(0.5, 8, 6);\n        const explosionMaterial = new THREE.MeshBasicMaterial({ \n            color: color,\n            transparent: true,\n            opacity: 1\n        });\n        \n        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);\n        explosion.position.copy(position);\n        \n        const explosionData = {\n            mesh: explosion,\n            time: 0,\n            duration: 0.8,\n            maxScale: scale * 3\n        };\n        \n        this.particleSystems.explosions.push(explosionData);\n        this.scene.add(explosion);\n        \n        // 폭발 스파크\n        this.createSparks(position, 20, 0xFF6666);\n        \n        // 폭발 연기\n        this.createSmoke(position, 5);\n        \n        this.playSound('explosion');\n    }\n    \n    /**\n     * 전기 볼트 생성 (두 점 사이)\n     */\n    createElectricBolt(startPos, endPos, segments = 8, color = 0x00FFFF) {\n        const points = this.generateLightningPath(startPos, endPos, segments);\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\n        const material = this.materials.electricity.clone();\n        material.color.setHex(color);\n        \n        const bolt = new THREE.Line(geometry, material);\n        \n        const boltData = {\n            mesh: bolt,\n            segments: points,\n            time: 0,\n            duration: 0.3\n        };\n        \n        this.particleSystems.electricity.push(boltData);\n        this.scene.add(bolt);\n        \n        this.playSound('electricShot');\n    }\n    \n    /**\n     * 번개 경로 생성 (지그재그)\n     */\n    generateLightningPath(start, end, segments) {\n        const points = [start.clone()];\n        \n        for (let i = 1; i < segments; i++) {\n            const progress = i / segments;\n            const point = start.clone().lerp(end, progress);\n            \n            // 랜덤 오프셋 추가\n            point.add(new THREE.Vector3(\n                (Math.random() - 0.5) * 0.5,\n                (Math.random() - 0.5) * 0.5,\n                (Math.random() - 0.5) * 0.5\n            ));\n            \n            points.push(point);\n        }\n        \n        points.push(end.clone());\n        return points;\n    }\n    \n    /**\n     * 번개 세그먼트 업데이트 (깜빡임)\n     */\n    updateLightningSegments(bolt) {\n        const positions = bolt.mesh.geometry.attributes.position.array;\n        \n        for (let i = 3; i < positions.length - 3; i += 3) {\n            // 중간 점들에 랜덤 지터 추가\n            positions[i] += (Math.random() - 0.5) * 0.1;\n            positions[i + 1] += (Math.random() - 0.5) * 0.1;\n            positions[i + 2] += (Math.random() - 0.5) * 0.1;\n        }\n        \n        bolt.mesh.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    /**\n     * 연기 생성\n     */\n    createSmoke(position, count = 5) {\n        for (let i = 0; i < count; i++) {\n            const smokeGeometry = new THREE.SphereGeometry(0.2, 6, 4);\n            const smokeMaterial = this.materials.smoke.clone();\n            \n            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);\n            smoke.position.copy(position);\n            smoke.position.add(new THREE.Vector3(\n                (Math.random() - 0.5) * 0.5,\n                0,\n                (Math.random() - 0.5) * 0.5\n            ));\n            \n            const smokeData = {\n                mesh: smoke,\n                position: smoke.position.clone(),\n                velocity: new THREE.Vector3(\n                    (Math.random() - 0.5) * 1,\n                    1 + Math.random(),\n                    (Math.random() - 0.5) * 1\n                ),\n                life: 2 + Math.random() * 2,\n                maxLife: 4\n            };\n            \n            smokeData.maxLife = smokeData.life;\n            \n            this.particleSystems.smoke.push(smokeData);\n            this.scene.add(smoke);\n        }\n    }\n    \n    /**\n     * 주변 번개 생성\n     */\n    createAmbientLightning() {\n        // 미로 상공에 번개 생성\n        const startPos = new THREE.Vector3(\n            Math.random() * 15,\n            8 + Math.random() * 2,\n            Math.random() * 15\n        );\n        \n        const endPos = new THREE.Vector3(\n            startPos.x + (Math.random() - 0.5) * 5,\n            startPos.y - 2 - Math.random() * 3,\n            startPos.z + (Math.random() - 0.5) * 5\n        );\n        \n        this.createElectricBolt(startPos, endPos, 12, 0x4444FF);\n        \n        // 번개와 함께 잠깐 밝아지는 효과\n        const flash = new THREE.PointLight(0x4444FF, 2, 20);\n        flash.position.copy(startPos);\n        this.scene.add(flash);\n        \n        setTimeout(() => {\n            this.scene.remove(flash);\n        }, 200);\n    }\n    \n    /**\n     * 승리 이펙트\n     */\n    createVictoryEffect() {\n        // 미로 중앙에서 대형 전기 폭발\n        const centerPos = new THREE.Vector3(7.5, 2, 7.5);\n        \n        // 여러 단계 폭발\n        setTimeout(() => this.createExplosion(centerPos, 2.0, 0xFFD700), 0);\n        setTimeout(() => this.createExplosion(centerPos, 3.0, 0x00FFFF), 300);\n        setTimeout(() => this.createExplosion(centerPos, 4.0, 0xFF66FF), 600);\n        \n        // 주변으로 번개 생성\n        for (let i = 0; i < 8; i++) {\n            setTimeout(() => {\n                const angle = (i / 8) * Math.PI * 2;\n                const targetPos = new THREE.Vector3(\n                    centerPos.x + Math.cos(angle) * 5,\n                    centerPos.y,\n                    centerPos.z + Math.sin(angle) * 5\n                );\n                this.createElectricBolt(centerPos, targetPos, 10, 0xFFD700);\n            }, i * 100);\n        }\n    }\n    \n    /**\n     * 총 발사 이펙트\n     */\n    createGunFireEffect(position, direction) {\n        // 총구 섬광\n        const muzzlePos = position.clone().add(direction.clone().multiplyScalar(0.3));\n        this.createSparks(muzzlePos, 5, 0x00FFFF);\n        \n        // 총구 연기\n        this.createSmoke(muzzlePos, 2);\n    }\n    \n    /**\n     * 적 피격 이펙트\n     */\n    createEnemyHitEffect(position) {\n        this.createSparks(position, 8, 0xFF4444);\n        this.createElectricBolt(\n            position,\n            position.clone().add(new THREE.Vector3(0, 1, 0)),\n            5,\n            0xFF6666\n        );\n        this.playSound('enemyHit');\n    }\n    \n    /**\n     * 플레이어 피격 이펙트\n     */\n    createPlayerHitEffect(position) {\n        this.createSparks(position, 6, 0xFF0000);\n        this.playSound('playerHit');\n    }\n    \n    /**\n     * 아이템 수집 이펙트\n     */\n    createItemCollectEffect(position, itemType) {\n        const colors = {\n            'COIN': 0xFFD700,\n            'POWER_CUBE': 0x00FFFF,\n            'HEALTH_PACK': 0xFF6B6B,\n            'SPEED_BOOST': 0x00FF00,\n            'SHIELD': 0x4169E1\n        };\n        \n        const color = colors[itemType] || 0xFFFFFF;\n        \n        this.createSparks(position, 15, color);\n        \n        // 상승하는 링 이펙트\n        this.createRisingRing(position, color);\n        \n        this.playSound('coinCollect');\n    }\n    \n    /**\n     * 상승하는 링 이펙트\n     */\n    createRisingRing(position, color) {\n        const ringGeometry = new THREE.RingGeometry(0.1, 0.3, 16);\n        const ringMaterial = new THREE.MeshBasicMaterial({ \n            color: color,\n            transparent: true,\n            opacity: 0.8,\n            side: THREE.DoubleSide\n        });\n        \n        const ring = new THREE.Mesh(ringGeometry, ringMaterial);\n        ring.position.copy(position);\n        ring.rotation.x = -Math.PI / 2;\n        \n        this.scene.add(ring);\n        \n        // 애니메이션\n        const startTime = performance.now();\n        const duration = 1000;\n        \n        const animateRing = () => {\n            const elapsed = performance.now() - startTime;\n            const progress = elapsed / duration;\n            \n            if (progress < 1) {\n                ring.position.y = position.y + progress * 2;\n                ring.scale.setScalar(1 + progress * 2);\n                ring.material.opacity = 0.8 * (1 - progress);\n                requestAnimationFrame(animateRing);\n            } else {\n                this.scene.remove(ring);\n            }\n        };\n        \n        animateRing();\n    }\n    \n    /**\n     * 사운드 재생\n     */\n    playSound(soundName, volume = 1.0) {\n        if (!this.audioSystem.enabled) return;\n        \n        console.log(`🔊 [${soundName}] 사운드 재생 (볼륨: ${volume * this.audioSystem.volume})`);\n        \n        // 실제 구현에서는 웹 오디오 API 사용\n        /*\n        if (this.audioSystem.sounds[soundName]) {\n            const audio = new Audio(this.audioSystem.sounds[soundName]);\n            audio.volume = volume * this.audioSystem.volume;\n            audio.play().catch(e => console.warn('오디오 재생 실패:', e));\n        }\n        */\n    }\n    \n    /**\n     * 이펙트 정리\n     */\n    cleanupEffects() {\n        // 파티클 수 제한\n        const totalParticles = \n            this.particleSystems.sparks.length +\n            this.particleSystems.explosions.length +\n            this.particleSystems.electricity.length +\n            this.particleSystems.smoke.length;\n        \n        if (totalParticles > this.settings.maxParticles) {\n            // 오래된 파티클부터 제거\n            this.removeOldestParticles();\n        }\n    }\n    \n    /**\n     * 가장 오래된 파티클 제거\n     */\n    removeOldestParticles() {\n        const systems = ['sparks', 'explosions', 'electricity', 'smoke'];\n        \n        systems.forEach(systemName => {\n            const system = this.particleSystems[systemName];\n            if (system.length > 0) {\n                const oldest = system.shift();\n                if (oldest && oldest.mesh) {\n                    this.scene.remove(oldest.mesh);\n                }\n            }\n        });\n    }\n    \n    /**\n     * 모든 이펙트 정리 (리셋 시)\n     */\n    reset() {\n        // 모든 파티클 시스템 정리\n        Object.values(this.particleSystems).forEach(system => {\n            system.forEach(effect => {\n                if (effect.mesh) {\n                    this.scene.remove(effect.mesh);\n                }\n            });\n            system.length = 0;\n        });\n        \n        console.log('✨ 이펙트 시스템 리셋');\n    }\n    \n    /**\n     * 설정 업데이트\n     */\n    updateSettings(newSettings) {\n        this.settings = { ...this.settings, ...newSettings };\n        \n        // 품질 설정에 따른 파티클 수 조정\n        const qualityMultipliers = {\n            'low': 0.3,\n            'medium': 0.7,\n            'high': 1.0\n        };\n        \n        const multiplier = qualityMultipliers[this.settings.particleQuality] || 1.0;\n        this.settings.maxParticles = Math.floor(500 * multiplier);\n        this.environmentEffects.atmosphericParticles.count = Math.floor(50 * multiplier);\n    }\n    \n    /**\n     * 현재 상태 반환\n     */\n    getState() {\n        const totalEffects = Object.values(this.particleSystems)\n            .reduce((sum, system) => sum + system.length, 0);\n        \n        return {\n            totalEffects,\n            maxEffects: this.settings.maxParticles,\n            particleQuality: this.settings.particleQuality,\n            audioEnabled: this.audioSystem.enabled\n        };\n    }\n}